[
  {
    "objectID": "practices/seq.html",
    "href": "practices/seq.html",
    "title": "Выравнивание биологических последовательностей",
    "section": "",
    "text": "Выравнивание последовательностей — биоинформатический метод, основанный на размещении двух или более последовательностей мономеров ДНК, РНК или белков друг под другом таким образом, чтобы можно было легко увидеть сходные участки в этих последовательностях. Сходство первичных структур двух молекул может отражать их функциональные, структурные или эволюционные взаимосвязи.\nВыравнивание — это фундаментальный инструмент, с которым постоянно работают в биоинформатике, геномике, клинических исследованиях. Он используется для анализа данных секвенирования, изучения патогенов, разработки лекарств и в других практических задачах.\n\n\n\nhttp://ugene.net/multiple-sequence-alignment-overview/"
  },
  {
    "objectID": "practices/seq.html#метод-illumina",
    "href": "practices/seq.html#метод-illumina",
    "title": "Выравнивание биологических последовательностей",
    "section": "Метод Illumina",
    "text": "Метод Illumina\nЭтот метод секвенирования основан на использовании обратимых красителей-терминаторов, которые позволяют идентифицировать отдельные нуклеотиды по мере того, как они омывают нити ДНК. Он также может использоваться для секвенирования целых геномов и регионов, анализа транскриптома, метагеномики, обнаружения малых РНК, профилирования метилирования и анализа взаимодействия белков и нуклеиновых кислот в масштабах всего генома. Данный метод является на данный момент самым популярным методом NGS.\n\n\n\nhttps://en.wikipedia.org/wiki/Illumina_dye_sequencing#/media/File:Cluster_Generation.png\n\n\n\nПодготовка ДНК\n\nИсследуемая двуцепочечная ДНК фрагментируется.\nК двуцепочечным фрагментам с помощью ДНК-лигазы пришивается небольшой ДНК-фрагмент — адаптер. Адаптер состоит из двух олигонуклеотидов, частично комплементарных друг другу. При смешении таких олигонуклеотидов образуется «вилка», «ножка» которой состоит из двуцепочечной ДНК (там где олигонуклеотиды комплементарны), две «ручки» состоят из одноцепочечной ДНК. Лигаза пришивает два адаптера за «ножку» к каждому концу исследуемого фрагмента ДНК.\nДалее происходит амплификация полученных фрагментов ДНК с помощью ПЦР. В результате образуется множество фрагментов двуцепочечной ДНК, на одном конце — первый олигонуклеотид, составляющий адаптер, на другом конце — второй.\n\n\n\nПодготовка ячейки (flowcell)\nЯчейка содержит внутри 8 дорожек. В каждой дорожке может секвенироваться отдельный образец.\n\nНа поверхность каждой дорожки пришиваются одноцепочечные олигонуклеотиды. Такие же, что использовались при создании адаптера. Эти олигонуклеотиды в будущем будут связывать исследуемую ДНК (так как они комплементарны адаптеру) и служить праймерами для мостиковой амплификации. В одном из олигонуклеотидов есть сайт для рестриктазы.\n\n\n\nМостиковая амплификация\n\nПроизводится плавление исследуемой ДНК и уже одноцепочечные её фрагменты отжигаются на закрепленных на подложке праймерах.\nВ систему добавляется все необходимое для ПЦР, кроме праймеров. Праймеры уже есть — это иммобилизованные олигонуклеотиды.\nПолимераза достраивает комплементарную цепь. Теперь каждый исследуемый фрагмент выглядит как двуцепочечная ДНК, конец одной из цепей пришит к поверхности ячейки.\nПроводится плавление двуцепочечной ДНК, в результате которого комплементарные цепи ДНК расходятся. Цепь ДНК, которая не была закреплена на поверхности, удаляется. Каждый исследуемый фрагмент представляет собой одноцепочечную ДНК, пришитую к поверхности ячейки.\nСвоим незакрепленным концом цепь ДНК может образовать комплементарное взаимодействие со вторым иммобилизованным олигонуклеотидом. Теперь фрагмент расположен в виде «мостика» — один конец пришит к поверхности, другой держится за счет комплементарных взаимодействий.\nПолимераза снова достраивает комплементарную цепь, используя в качестве праймера второй олигонуклеотид.\nПосле плавления и удаления незакрепленных цепей ДНК фрагмент выглядит как две одноцепочечные ДНК, прикрепленные к поверхности. Одна цепь расположена «вверх ногами» относительно прикрепленной ДНК в пункте 1. Свободный конец каждой из цепей может образовать мостик с иммобилизованным олигонуклеотидом. Далее повторяются пункты 6 и 7.\nПосле амплификации вокруг каждого закрепленного фрагмента появляется большое количество его копий. Половина из копий расположена «вверх ногами». Добавляется рестриктаза, которая расщепляет один из прикрепленных олигонуклеотидов — ненужные копии вымываются. Теперь все копии ДНК, получившиеся в результате амплификации из начального фрагмента, расположены одинаково.\n\n\n\nСеквенирование\nДНК-зависимая ДНК-полимераза синтезирует комплементарную цепь. Встраивание каждого нового нуклеотида регистрируется с помощью камеры.\n\nВ систему добавляются праймеры и ДНК-полимераза.\nВ систему добавляются 3′-O-азидометил 2′-деоксинуклеозид трифосфаты (A, C, G и T), каждый с отделяемой флюоресцентной меткой своего цвета. Наличие 3′-O-азидометила не позволяет ДНК-полимеразе присоединить больше одного нуклеотида.\nПолимераза присоединяет один модифицированный нуклеотид, оставшиеся нуклеотиды вымываются.\nЯчейка освещается коротким импульсом лазера. Присоединенный флюорофор светится своим цветом. Так как после амплификации вокруг каждой молекулы ДНК есть множество её копий, свет множества одинаковых флюорофоров можно зарегистрировать.\nВ систему добавляется вещество (TCEP), из-за которого флюорофор и азидометил отделяются и вымываются. 3′-гидроксильная группа становится доступной для присоединения ещё одного нуклеотида.\nПовторяются пункты 2-5.\n\nПосле секвенирования, секвенатор Illumina выдает FASTQ файл чтений."
  },
  {
    "objectID": "practices/seq.html#выравнивание-данных-ngs",
    "href": "practices/seq.html#выравнивание-данных-ngs",
    "title": "Выравнивание биологических последовательностей",
    "section": "Выравнивание данных NGS",
    "text": "Выравнивание данных NGS\n\nSingle or paired?\nСеквенирование single-read подразумевает секвенирование ДНК только с одного конца и является самым простым способом использования секвенирования Illumina. В отличие от single-read секвенирования, paired-end секвенирование позволяет секвенировать оба конца фрагмента и генерировать высококачественные, выравниваемые данные о последовательности. Paired-end секвенирование облегчает обнаружение геномных перестроек и повторяющихся элементов последовательности.\nПомимо того, что при одинаковых затратах времени и усилий на подготовку библиотеки получается вдвое больше чтений, последовательности, выровненные в виде пар чтений, позволяют более точно выравнивать чтения и обнаруживать варианты вставки-удаления (indel), что сложнее при использовании данных с одним чтением. Однако, преимуществом single-read секвенирования является его меньшая стоимость.\nПеред проведением выравнивания важно знать, являются ли чтения single/paired-end. В случае paired-end может быть либо 2 FASTQ-файла: (R1/first of pair) и (R2/second of pair), либо 1, с чередующимися ридами пар. Во втором случае часто требуется разделить такой единый, чередующийся (interleaved) файл на 2. Это можно сделать с помощью инструмента fastqtk1 командой:\nfastqtk deinterleave &lt;interleaved&gt;.fq out1.fq out2.fq\n\n\nQuality control\n\nFASTQC\nПеред выравниванием чтений NGS требуется контроль качества входных FASTQ файлов: некоторые риды могут быть прочитаны некачественно, зачастую проблемными оказываются последовательности в начале и в конце прочтения. Также, в некоторых случаях, требуется удалить последовательности адаптера, использованного при секвенировании.\n\n\n\nПример отчета FASTQC\n\n\nОдной из наиболее используемых программ для выполнения QC FASTQ файлов является FASTQC2. В сгенерированном им отчете в первую очередь нужно обращать внимание на такие пункты, как:\n\nPer base sequence quality - Если в начале либо в конце чтений качество ухудшается, то следует обрезать данные регионы перед проведением выравнивания.\nPer base sequence content - Процент каждого из нуклеотидов должен быть равным 25%, идеальный график данного пункта выглядит, как 4 разноцветных прямых. Если график становится кривым в начале/конце рида, то следует проверить чтения на наличие адаптерной последовательности и/или применить совет из пункта выше.\nOverrepresented sequences - Если FASTQ обнаруживает избыточно встреченные последовательности, то их желательно убрать на этапе QC.\n\nНа сайте FASTQC доступен пример отчета по “хорошим” и “плохим” данным.\n\n\nTrim Galore\nДля исправления всех недостатков FASTQ, обнаруженных с помощью FASTQC, можно использовать инструмент Trim Galore3 - он позволяет, как удалить конкретное число нуклеотидов с обоих сторон рида, так и отфильтровать их по качеству. Trim Galore автоматически узнает наиболее используемые адаптерные последовательности.\n\n\n\nAlignment"
  },
  {
    "objectID": "practices/seq.html#footnotes",
    "href": "practices/seq.html#footnotes",
    "title": "Выравнивание биологических последовательностей",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://github.com/ndaniel/fastqtk↩︎\nhttps://www.bioinformatics.babraham.ac.uk/projects/fastqc/↩︎\nhttps://github.com/FelixKrueger/TrimGalore/tree/master↩︎"
  },
  {
    "objectID": "practices/hmm.html",
    "href": "practices/hmm.html",
    "title": "Введение",
    "section": "",
    "text": "Скрытые Марковские модели"
  },
  {
    "objectID": "practices/hmm.html#предисловие",
    "href": "practices/hmm.html#предисловие",
    "title": "Введение",
    "section": "Предисловие",
    "text": "Предисловие\n\nЧто такое CpG-островки?\nCpG-островки — это специфические участки ДНК с высокой частотой сочетаний цитозина и гуанина (обозначаемых как CpG), которые играют важную роль в регуляции генов. Эти островки часто располагаются рядом с промоторами — участками, ответственными за запуск транскрипции генов, — особенно в геномах эукариот.\n\n\n\n\n\nОдной из ключевых особенностей CpG-островков в промоторных областях является то, что они обычно остаются неметилированными, что способствует активной экспрессии гена. Напротив, их метилирование может приводить к «выключению» гена, подавляя его активность. Поэтому состояние CpG-островков — метилированное или неметилированное — становится своего рода переключателем, который помогает регулировать, будет ли ген экспрессироваться или нет."
  },
  {
    "objectID": "practices/hmm.html#алгоритм-витерби-reminder",
    "href": "practices/hmm.html#алгоритм-витерби-reminder",
    "title": "Введение",
    "section": "Алгоритм Витерби (reminder)",
    "text": "Алгоритм Витерби (reminder)\nАлгоритм Витерби — это метод динамического программирования, который позволяет определить наиболее вероятную последовательность скрытых состояний в скрытой марковской модели (HMM) для данной последовательности наблюдаемых событий. Алгоритм вычисляет путь, который максимизирует вероятность наблюдаемой последовательности, путем итеративного расчета наивысшей вероятности для каждого состояния на каждом этапе. При этом сохраняется информация как о вероятностях, так и о «указателях» (backpointer), необходимых для восстановления оптимального пути по завершении расчетов. Благодаря рекурсивному подходу алгоритм эффективно отслеживает путь, ведущий к каждому состоянию, избегая необходимости полного перебора всех возможных путей.\nПочему выбран алгоритм Витерби для данной задачи? Алгоритм Витерби особенно подходит для выявления CpG-островков в последовательностях ДНК, так как он позволяет точно расшифровать последовательность в разные состояния (например, «CpG-островок» и «не-CpG-островок») на основе HMM. Высокая вычислительная эффективность делает его идеальным инструментом для анализа длинных последовательностей ДНК, типичных для биоинформатических исследований. Определяя наиболее вероятную последовательность скрытых состояний, алгоритм помогает выявлять биологически значимые области с высоким содержанием CG, что связано с функциями регуляции генов.\nAлгоритм Витерби находит широкое применение в различных областях биоинформатики и вычислительной биологии. Например, он используется для предсказания генов, помогая определить расположение экзонов и интронов в геномной последовательности. Алгоритм также применяется в множественном выравнивании последовательностей, где он помогает выровнять родственные биологические последовательности и выявить консервативные регионы. За пределами биоинформатики алгоритм Витерби также используется в системах распознавания речи, языковом моделировании и робототехнике для определения наиболее вероятной последовательности состояний в различных марковских системах.\n\nКак подготовить HMM. Частный случай.\nСостояния: В этой HMM предусмотрены два состояния — «CpG-островок» и «не-CpG-островок». Состояние CpG-островка представляет области генома с высокой частотой цитозин-гуаниновых динуклеотидов (CG), тогда как состояние не-CpG-островка охватывает стандартные участки генома с низким содержанием CG.\nВероятности перехода: Вероятности перехода между состояниями определяют, какова вероятность перемещения из одного состояния в другое. Например, вероятность остаться в состоянии CpG-островка может быть высокой, что отражает их цельный, локализованный характер. В то же время вероятность перехода из состояния «не-CpG-островок» в «CpG-островок» может быть ниже, так как CpG-островки обычно сконцентрированы в определенных участках генома, часто около промоторных регионов генов.\nВероятности эмиссии: Вероятности эмиссии описывают вероятность наблюдения конкретных нуклеотидов (A, C, G, T) в каждом состоянии. Для CpG-островков характерна более высокая вероятность появления нуклеотидов C и G, что отражает их уникальный состав, тогда как в не-CpG-областях эти вероятности распределены более равномерно.\nМоделирование CpG-островков: Параметры HMM — состояния, вероятности переходов и вероятности эмиссии — создают модель, способную распознать CpG-островки на основе их биологических особенностей, таких как высокое содержание CG и их расположение вблизи промоторных областей. Таким образом, модель не только различает CpG и не-CpG участки, но и выделяет те, что с наибольшей вероятностью играют роль в регуляции генов.\nГрафическое представление: Визуальная схема HMM наглядно отображает модель. В ней состояния представлены узлами, а переходы между ними — стрелками с указанием вероятностей. Такой граф помогает представить, как система переходит между состояниями и в какой последовательности.\n\n\n\n\n\nstateDiagram-v2\n    [*] --&gt; NonCpG\n\n    state \"Non-CpG\" as NonCpG\n    state \"CpG Island\" as CpG\n\n    NonCpG --&gt; NonCpG : p = 0.999\n    NonCpG --&gt; CpG : p = 0.001\n    CpG --&gt; CpG : p = 0.995\n    CpG --&gt; NonCpG : p = 0.005\n\n    note right of NonCpG\n        **Emission Probabilities:**\n        A: 0.30\n        C: 0.20\n        G: 0.20\n        T: 0.30\n    end note\n\n    note left of CpG\n        **Emission Probabilities:**\n        A: 0.15\n        C: 0.35\n        G: 0.35\n        T: 0.15\n    end note"
  },
  {
    "objectID": "practices/hmm.html#имплементация-алгоритма",
    "href": "practices/hmm.html#имплементация-алгоритма",
    "title": "Введение",
    "section": "Имплементация алгоритма",
    "text": "Имплементация алгоритма\nИнициализация матрицы Витерби При работе с алгоритмом Витерби первым шагом является инициализация матрицы, в которой будут храниться вероятности наиболее вероятных путей для каждого состояния на каждом шаге последовательности. Эта матрица позволяет моделировать вероятностный путь через последовательность ДНК, учитывая наиболее вероятные переходы между состояниями.\nИтерация по последовательности В процессе итерации по последовательности ДНК, шаг за шагом, вычисляется вероятность нахождения в каждом из возможных состояний (например, «CpG-островок» или «не-CpG-островок») на каждом этапе последовательности. Этот шаг позволяет постепенно накапливать вероятности, связанные с каждым состоянием в последовательности.\nПостроение и использование матрицы Витерби Создание матрицы Витерби (V): Эта матрица (V) используется для хранения максимальной вероятности достижения каждого состояния в каждый момент последовательности. Дополнительно создается матрица указателей (backpointer), которая сохраняет наиболее вероятное предыдущее состояние для каждого текущего состояния, что будет полезно на этапе определения пути.\nВыбор конечного состояния: В последней колонке матрицы V определяется состояние с наивысшей вероятностью, которое считается конечной точкой на наиболее вероятном пути.\nОбратный проход (backtracking): Начиная с выбранного конечного состояния, матрица указателей используется для «обратного прохода» через последовательность, чтобы восстановить наиболее вероятный путь скрытых состояний. Этот процесс позволяет точно определить участки, такие как CpG-островки, в анализируемой последовательности.\nПример имплементации алгоритма (псевдокод)\n\nВходные данные:\n\n\\(O = {o_1, o_2, \\dots, o_N}\\): Пространство наблюдений\n\\(S = {s_1, s_2, \\dots, s_K}\\): Пространство состояний\n\\(Y = {y_1, y_2, \\dots, y_T}\\): Последовательность наблюдений\n\\(A\\): Матрица переходов из \\(i\\)-го состояния в \\(j\\)-е, размером \\(K \\times K\\)\n\\(B\\): Матрица эмиссии размера \\(K \\times N\\), определяющая вероятность наблюдения \\(o_j\\) из состояния \\(s_i\\)\n\\(\\pi\\): Массив начальных вероятностей размером \\(K\\), показывающий вероятность того, что начальное состояние — \\(s_i\\)\n\n\nViterbi(O, S, P, Y, A, B) \n    for j = 1 to K\n        TState[j, 1] = P[j] * B[j, Y[1]]\n        TIndex[j, 1] = 0\n    for i = 2 to T\n        for j = 1 to K\n            TIndex[j, i] = argmax_k_in_K (TState[k, i-1] * A[k, j] * B[j, Y[i]])\n            TState[j, i] = TState[TIndex[j, i], i-1] * A[TIndex[j, i], j] * B[j, Y[i]]\n    X[T] = argmax_1 &lt;= k &lt;= K (TState[k, T]) \n    for i = T downto 2\n        X[i-1] = TIndex[X[i], i]\n    return X"
  },
  {
    "objectID": "practices/hmm.html#sensitivity-and-specificity",
    "href": "practices/hmm.html#sensitivity-and-specificity",
    "title": "Введение",
    "section": "Sensitivity and specificity",
    "text": "Sensitivity and specificity\nЧувствительность (sensitivity) и специфичность (specificity) — статистические показатели диагностического теста по выявлению больных и здоровых, выводимых из ошибок первого и второго рода в бинарной классификации. Значения обоих показателей лежат в пределах от 0 до 1.\nЧувствительность (истинно положительная пропорция) отражает долю положительных результатов, которые правильно идентифицированы как таковые. Иными словами, чувствительность диагностического теста показывает вероятность того, что больной субъект будет классифицирован именно как больной.[1]\nСпецифичность (истинно отрицательная пропорция) отражает долю отрицательных результатов, которые правильно идентифицированы как таковые, то есть вероятность того, что не больные субъекты будут классифицированы именно как не больные.[1]\nДля примера можно рассмотреть группу, некоторые члены которой страдают определённым заболеванием, а остальные — нет. Предположим, что существует метод для разграничения этих двух долей, но при этом некоторые из здоровых классифицируются как больные, а некоторые из больных — как здоровые. Под «здоровым» и «больным» будем подразумевать отсутствие или наличие рассматриваемого заболевания. Это иллюстрируется на рисунке ниже «Общая модель чувствительности и специфичности»."
  },
  {
    "objectID": "practices/hmm.html#f-score",
    "href": "practices/hmm.html#f-score",
    "title": "Введение",
    "section": "F-score",
    "text": "F-score\nF-score, или F-мера, – это метрика, широко применяемая для оценки качества классификационных моделей, особенно при работе с несбалансированными данными. Она объединяет точность (precision) и полноту (recall) в одно значение. Основная формула F-score выглядит так:\n\\[\nF_β​=(1+\\beta^2)⋅\\frac{\\text{precision}\\cdot\\text{recall}}{(\\beta^2\\cdot\\text{precision})+\\text{recall}}\n\\]\n\n\n\n\n\n\nОпределения\nТочность (Precision): показывает, какая доля предсказанных моделью положительных результатов действительно является положительной. Она определяется как:\n\\[\n\\text{precision}=\\frac{TP}{TP+FP}\n\\]\nгде \\(TP\\) - количество истинных положительных случаев, а \\(FP\\) - количество ложных положительных\nПолнота (Recall): отражает, какая доля истинных положительных объектов была найдена моделью. Формула:\n\\[\n\\text{recall}=\\frac{TP}{TP+FN}\n\\]\nЗдесь \\(FN\\) - количество ложных отрицательных случаев\n\n\nПараметр \\(\\beta\\)\nПараметр \\(\\beta\\) в формуле F-score используется для регулировки относительной важности точности и полноты. Чем больше $\\beta$, тем выше значение полноты по отношению к точности. Соответственно, \\(\\beta &lt; 1\\) усиливает важность точности. Например:\n\nF1-score (\\(\\beta\\)=1) – точность и полнота равны по весу.\nF2-score (\\(\\beta\\)=2) – полнота важнее в два раза, чем точность.\n\n\n\nПрименение F-score\nF-score широко применяется для оценки классификационных моделей, особенно в случаях, когда данные несбалансированы. В таких ситуациях стандартная точность модели может вводить в заблуждение, так как высокая точность может быть результатом редкого появления положительных классов. Например, в задаче обнаружения мошенничества большинство транзакций обычно честные, и классификатор, прогнозирующий все транзакции как честные, получит высокую точность, хотя он не обнаружит ни одного случая мошенничества. Здесь F-score становится важным инструментом, потому что он учитывает как точность (precision), так и полноту (recall), обеспечивая более сбалансированную оценку.\nF-score особенно полезен в задачах информационного поиска, текстовой классификации, медицинской диагностики и других областях, где важно одновременно находить как можно больше значимых объектов (полнота) и минимизировать количество ложных срабатываний (точность). Например, в медицинских тестах при классификации болезни важно не только найти как можно больше положительных случаев (высокая полнота), но и избежать большого количества ложных диагнозов (высокая точность), которые могут вызвать ненужное беспокойство.\nТаким образом, F-score является ключевой метрикой в задачах, где важно балансировать между полнотой и точностью, и может быть адаптирован для конкретных потребностей, выбирая подходящее значение параметра \\(\\beta\\)."
  },
  {
    "objectID": "practices/hmm.html#цель",
    "href": "practices/hmm.html#цель",
    "title": "Введение",
    "section": "Цель",
    "text": "Цель\nНаучиться применять скрытую марковскую модель (HMM) для обнаружения CpG-островков в последовательности ДНК, закрепив теоретические знания, полученные на занятиях."
  },
  {
    "objectID": "practices/hmm.html#задачи",
    "href": "practices/hmm.html#задачи",
    "title": "Введение",
    "section": "Задачи",
    "text": "Задачи\n\nОпределение модели: Задайте HMM с двумя состояниями («CpG» и «не-CpG»), указав разумные начальные значения для вероятностей переходов и эмиссий.\n\n\n\n\n\n\nNote\n\n\n\nДля этого шага Вы можете использовать те же параметры, что и во время практического занятия.\n\n\nРеализация алгоритма: Реализуйте алгоритм Витерби на Python для поиска CpG-островков в длинной последовательности ДНК. Этот этап опирается на материал, изученный на занятии, где вы узнали, как применять алгоритм Витерби для нахождения наиболее вероятной последовательности состояний. Теперь ваша задача — применить эти знания к большему и более сложному набору данных.\n\n\n\n\n\n\nNote\n\n\n\nВ качестве генома для анализа мы будем использовать геном рыбки Данио-рерио (Danio Rerio, Zebrafish). Данио-рерио является одним из наиболее изученных позвоночных наряду с крысами и мышами. Одним из преимуществ использования этой рыбы в качестве модельного организма является относительно небольшая длина генома ~1.5Gb.\nРеференсную последовательность генома Данио-рерио нужно скачать с сайта UCSC:\nhttp://hgdownload.soe.ucsc.edu/goldenPath/danRer11/bigZips/danRer11.fa.gz\nАннотацию CpG островков следует скачаь с помощью UCSC Table Browser (в BED формате):\nhttps://genome.ucsc.edu/cgi-bin/hgTables\n\n\nОбучение алгоритмом Баум-Велша: Реализуйте алгоритм Баум-Велша для уточнения параметров модели. Этот алгоритм выбран для закрепления навыков, так как он дополняет алгоритм Витерби. В то время как Витерби используется для нахождения наиболее вероятного пути состояний, Баум-Велш позволяет подбирать оптимальные параметры HMM, опираясь исключительно на наблюдаемые данные, когда точные пути состояний неизвестны.\n\n\n\n\n\n\nTip\n\n\n\nВнимательно изучите принцип работы алгоритма: https://en.wikipedia.org/wiki/Baum–Welch_algorithm\nТакже, в качестве подсказки, приводим алгоритм на псевдокоде:\n\nBaumWelch(observations, states, transitions, emissions, max_iterations):\n    Initialize transition and emission probabilities\n    for iteration in range(max_iterations):\n        # Expectation Step (E-Step)\n        for each observation sequence:\n            Compute forward probabilities (alpha)\n            Compute backward probabilities (beta)\n\n        # Maximization Step (M-Step)\n        for each state i:\n            for each state j:\n                Update transition probability from state i to j\n\n            for each observation symbol k:\n                Update emission probability for state i to symbol k\n\n    return updated transition and emission probabilities\n\nА также метод подсчета alpha:\n\nComputeAlpha(observations, states, start_prob, transition_prob, emission_prob):\n    Initialize alpha for the first observation:\n    for each state i:\n        alpha[0][i] = start_prob[i] * emission_prob[i][observations[0]]\n\n    # Recursively compute alpha for the rest of the observations\n    for t from 1 to length(observations) - 1:\n        for each state i:\n            alpha[t][i] = 0\n            for each state j:\n                alpha[t][i] += alpha[t - 1][j] * transition_prob[j][i]\n            alpha[t][i] *= emission_prob[i][observations[t]]\n\n    return alpha\n\nМетод подсчета beta Вам требуется придумать самим.\n\n\nСравнение с реальными данными: Возьмите последовательность ДНК из публичной базы данных (например, NCBI) с известными CpG-островками и проверьте, насколько модель совпадает с существующими аннотациями. Сравнение результатов с реальными данными поможет оценить практическую полезность и точность модели.\nОценка точности: Рассчитайте чувствительность, специфичность и F1-метрику для оценки работы модели, обсудив возможные причины расхождений. Эти метрики помогут количественно оценить точность модели и выявить направления для улучшения.\n\nМатериалы для сдачи:\n\nPython-код: Отправьте документированные скрипты на Python.\nОтчет (3–5 страниц): Подготовьте подробный отчет, включающий описание подхода, трудностей, анализа чувствительности и результатов."
  },
  {
    "objectID": "practices/msa.html",
    "href": "practices/msa.html",
    "title": "Множественное выравнивание",
    "section": "",
    "text": "Множественное выравнивание последовательностей (Multiple Sequence Alignment, MSA) - фундаментальный метод в биоинформатике, используемых для сравнения трех или более биологических последовательностей. MSA позволяет выявить эволюционные взаимосвязи между последовательностями, определить консервативные участки и функциональные домены, а также предсказать структуру и функцию белков.\nMSA используется для:\n\nВыявления консервативных регионов и функциональных доменов - они обычно имеют низковариативную последовательность\nОпределения эволюционных взаимосвязей - эволюция приводит к изменению последовательностей в определённых участках. По ним можно восстанавливать эволюционные расхождения организмов.\nПредсказания структуры и функции белков - если у белка с неизвестной функцией есть участок идентичный участку от другого белка с известной функцией, то можно предположить, что неизвестный белок имеет схожую функцию и локализацию.\nИдентификация мотивов и паттернов - в ДНК можно встретить последовательности, которые могут ничего не кодировать, но иметь строго определённую последовательность. Это может быть место посадки транскрипционного фактора без которого не продолжится определенный метаболический путь.\n\nОчевидное отличие отличие от парного выравнивания - множественное выравнивание учитывает сходство между всеми последовательностями одновременно. Это делает его более информативным, но и более вычислительно сложным.\nГотовое выравнивание последовательностей еще по-другому называется профилем. \nНапомним себе о алгоритмах используемых для построения таких профилей..."
  },
  {
    "objectID": "practices/msa.html#алгоритмы-прогрессивного-выравнивания",
    "href": "practices/msa.html#алгоритмы-прогрессивного-выравнивания",
    "title": "Множественное выравнивание",
    "section": "Алгоритмы прогрессивного выравнивания",
    "text": "Алгоритмы прогрессивного выравнивания\nОдин из наиболее широко используемых подходов MSA. Он предполагает постепенное построение выравнивания путем добавления последовательностей по одной за раз.\n\nШаги:\n\nПопарное выравнивание всех последовательностей друг с другом, в простейшем случае используя метод глобального выравнивания Нидлмана-Вунша.\nСоздание матрицы расстояний на основе результатов парного выравнивания.\nСоздание направляющего бинарного дерева, в простейшем варианте - используя метод ближайших соседей (об этом на следующей практике).\nПостепенное выравнивание последовательностей в соответствии с бинарным деревом: начиная с листьев (наиболее близких последовательностей) и направляясь к корню, выравнивая всё менее похожие последовательности в одно выравнивание.\n\n\n\n\nV. Ranwez, N. Chantret - “Strengths and Limits of Multiple Sequence Alignment and Filtering Methods”\n\n\n\n\nПрограммы:\n\nCLustalW - строит направляющее дерево, используя матрицу расстояний, полученную из парных оценок (pairwise scores), а затем выравнивает последовательности шаг за шагом на основе этого дерева (Thompson, Higgins, and Gibson 1994).\n\n\n\n\n\n\n\nNote\n\n\n\nClustal Omega - версия ClustalW, использующая скрытые марковские модели (HMM) для построения профилей, а также имеющая возможность запуска в многопоточном режиме (Sievers et al. 2011).\n\n\n\nT-Coffee (Notredame, Higgins, and Heringa 2000) - улучшает подход к прогрессивному выравниванию за нескольких приёмов:\n\nT-coffee создаёт библиотеки (большой набор) попарных локальных и глобальных выравниваний (в т.ч. с использованием алгоритма ClustalW)\nДалее расширяет библиотеку за счёт добавления к каждой паре выравнивания третью последовательность\nТаким образом парные выравнивания уточняются, а каждой паре остатков присваивается вес\n\n\n\n\nПлюсы и минусы\n(+) Быстрая и нетребовательная работа с большим количеством последовательностей.\n(+) Отлично выравнивает, если последовательности очень похожи.\n(-) Ошибки, появившиеся в первых выравниваниях “распространяются” далее, что приводит к потенциально неточным результатам\n(-) Поскольку прогрессивные методы являются эвристическими, то не гарантируют схождения к глобальному оптимуму\n(-) Не подходит для очень разных последовательностей.\n(-) Страдает биологический смысл выравнивания"
  },
  {
    "objectID": "practices/msa.html#итеративные-алгоритмы-уточнения",
    "href": "practices/msa.html#итеративные-алгоритмы-уточнения",
    "title": "Множественное выравнивание",
    "section": "Итеративные алгоритмы уточнения",
    "text": "Итеративные алгоритмы уточнения\nИтеративные методы начинают с начального выравнивания и затем улучшают его путем многократных циклов оптимизации.\n\nШаги:\n\nСоздать начальное выравнивание (часто используя Алгоритмы прогрессивного выравнивания)\nВыберите последовательность или подмножество последовательностей из текущего выравнивания для уточнения. Это может быть сделано различными способами:\n\nВыбор и удаление одной последовательности за раз;\nВыбор и удаление последовательностей на основе критериев;\nСлучайное разбиение выравнивания на два набора последовательностей.\n\nУдалённую(-ые) последовательность(-и) выровнять заново на оставшийся профиль выравнивания или, если было сделано разбиение на два набора, то перевыровнять эти два набора (профиля) последовательностей\nОценить новое выравнивание с помощью функции оценки (критерия).\nЕсли новое выравнивание улучшает оценку, то принять его в качестве текущего, а иначе сохранить предыдущее выравнивание.\nПовторять шаги 2-5 до тех пор, пока не будет достигнут минимум критерия или максимальное количество итерацй\n\nПример итеративного уточнения за счёт разбиения на два набора и перевыравнивания двух наборов последовательностей (профилей). Здесь \\(S_{TA}\\) - score of tested alignment, \\(S_{CA}\\) - score of current alignment:\n\n\n\nV. Ranwez, N. Chantret - “Strengths and Limits of Multiple Sequence Alignment and Filtering Methods”\n\n\n\n\nПрограммы:\n\nMUSCLE (Multiple Sequence Comparison by Log-Expectation) - на каждой итерации делит выравнивание на два профиля и перевыравнивает их друг на друга. Использует оценку логарифмического ожидания для построения выравнивания (Edgar 2004).\nMAFFT (Multiple Alignment using Fast Fourier Transform) - Использует быстрое преобразование Фурье для построения направляющего дерева, быстрого попарного выравнивания и итеративного уточнения. Подбирает стратегию выравнивания в зависимости от количества данных: от быстрого, но грубого до медленного, но точного (Katoh et al. 2002).\n\n\n\nПлюсы и минусы\n(+) Как правило, генерирует более точные выравнивания, чем просто прогрессивные методы.\n(+) Уменьшает влияние ранних ошибок выравнивания\n(+) Легче справляется с разнородными последовательностями\n(-) Требовательны к ресурсам при работе с очень большими наборами данных.\n(-) Страдает биологический смысл выравнивания\n(-) Плохое начальное выравнивание всё еще может испортить последующее выравнивание"
  },
  {
    "objectID": "practices/msa.html#другие-важные-алгоритмы",
    "href": "practices/msa.html#другие-важные-алгоритмы",
    "title": "Множественное выравнивание",
    "section": "Другие важные алгоритмы",
    "text": "Другие важные алгоритмы\n\nPrank (Löytynoja 2014)\n\nОчень немногие из методов MSA учитывают лежащий в основе выравниваний эволюционный процесс, и prank является заметным исключением.\nОднако за счет того, что биологическая задача превалирует над математической, то выравнивания могут оказаться неэффективными - в том числе по вычислительной мощности.\n\nKalign (Lassmann and Sonnhammer 2005)\n\nПо сравнению с остальными алгоритмами, он вычислительно эффективнее и быстрее. Поэтому, если надо создать “прикидочное” выравнивание, то он хорошо для этого подходит.\nИспользует алгоритм сопоставления строк\nПлохо справляется с очень непохожими последовательностями\nМеньше опций для кастомизации и улучшения выравнивания"
  },
  {
    "objectID": "practices/msa.html#clustal-.aln",
    "href": "practices/msa.html#clustal-.aln",
    "title": "Множественное выравнивание",
    "section": "clustal (.aln)",
    "text": "clustal (.aln)\nCLUSTAL W 2.1 multiple sequence alignment \n\nseq1       MAKVLLGPVAAVVLPSTGGEQALTV-DGLSTAVTRD\nseq2       MA-LLPGGPVLLPPLTGGEKAVTVRNGGLSTAVTRD\nseq3       MAVLVGGGPVALPSTGAQAVTVKNGGLSTAVTRDRD\nseq4       MKKVLVGPLAALVLPSTGKAVTKNDGLSTAVTRDRD\n           ** *  ** *   ** * ** *  *  ******  **\n\n\n\n\n\n\nTip\n\n\n\n«*» - звёздочка означает, что остатки в этом столбце идентичны во всех последовательностях в выравнивании.\n«:» - двоеточие означает, что наблюдаются консервативные замены (слабо влияющие на функцию).\n«.» - точка означает, что наблюдаются полуконсервативные замены.\n\n\nПоследовательности представлены блоками по 60 остатков. В начале пишется нащвание, в конце номер последнего остатка."
  },
  {
    "objectID": "practices/msa.html#phylip-.phy",
    "href": "practices/msa.html#phylip-.phy",
    "title": "Множественное выравнивание",
    "section": "phylip (.phy)",
    "text": "phylip (.phy)\n 4 42\nseq1       MAKVLLGPVA AVVLPSTGGEQ ALTV-DGLST AVTRD\nseq2       MA-LLPGGPV LLPPLTGGEKA VTVRNGGLST AVTRD\nseq3       MAVLVGGGPV ALPSTGAQAVT VKNGGLSTAV TRDRD\nseq4       MKKVLVGPLA ALVLPSTGKAV TKNDGLSTAV TRDRD\nСверху написаны количество последовательностей и длина выравнивания."
  },
  {
    "objectID": "practices/msa.html#nexus-.nxs",
    "href": "practices/msa.html#nexus-.nxs",
    "title": "Множественное выравнивание",
    "section": "nexus (.nxs)",
    "text": "nexus (.nxs)\n#NEXUS\n\nBEGIN DATA;\n    DIMENSIONS NTAX=4 NCHAR=42;\n    FORMAT DATATYPE=PROTEIN GAP=- MISSING=?;\n    MATRIX\nseq1    MAKVLLGPVAAVVLPSTGGEQALTV-DGLSTAVTRD\nseq2    MA-LLPGGPVLLPPLTGGEKAVTVRNGGLSTAVTRD\nseq3    MAVLVGGGPVALPSTGAQAVTVKNGGLSTAVTRDRD\nseq4    MKKVLVGPLAALVLPSTGKAVTKNDGLSTAVTRDRD\n;\nEND;\nСамый информативный формат, но и самый “громоздкий”. Внутри сразу написано количество последовательностей с длиной выравнивания, а также какими символами обозначаются пропуски."
  },
  {
    "objectID": "practices/msa.html#fasta-.fas.fa.fasta.fna.faa",
    "href": "practices/msa.html#fasta-.fas.fa.fasta.fna.faa",
    "title": "Множественное выравнивание",
    "section": "fasta (.fas/.fa/.fasta/.fna/.faa)",
    "text": "fasta (.fas/.fa/.fasta/.fna/.faa)\n&gt;seq1\nMAKVLLGPVAAVVLPSTGGEQALTV-DGLSTAVTRD\n&gt;seq2\nMA-LLPGGPVLLPPLTGGEKAVTVRNGGLSTAVTRD\n&gt;seq3\nMAVLVGGGPVALPSTGAQAVTVKNGGLSTAVTRDRD\n&gt;seq4\nMKKVLVGPLAALVLPSTGKAVTKNDGLSTAVTRDRD\nЭтот формат нам уже знаком, поэтому далее им и будем пользоваться."
  },
  {
    "objectID": "practices/msa.html#выравнивание-нуклеотидных-последовательностей",
    "href": "practices/msa.html#выравнивание-нуклеотидных-последовательностей",
    "title": "Множественное выравнивание",
    "section": "Выравнивание нуклеотидных последовательностей",
    "text": "Выравнивание нуклеотидных последовательностей\n\nДанные\nСкачайте их отсюда: ССЫЛКА\nМы будем использовать файлы из папки nucleotide_msa. Здесь находтся .fasta файлы с последовательностями генов 16S рРНК бактерий.\n\n\n\n\n\n\nNote\n\n\n\n16S рРНК — один из трёх основных типов рибосомальных РНК, образующих основу рибосом прокариот.\n\n\nНам они интересны, потому что они имеют консервативные и вариабельные области (V1-9)\n\n\n\nПо оси ординат - значение, обозначающее разнообразие (вариабельность). По оси абсцисс - номер нуклеотида в 16S рРНК (Johnson et al. 2019)\n\n\nВ теории, консервативные области 16S разных организмов должны хорошо выровняться, а вариабельные - нет. Проверим это на практике.\n\n\nЗапускаем программы для выравнивания\nВ директории есть файлы с около 600 последовательностями (16s_complete.fna) и с 30 (16s_complete_30.fna). Выбирайте тот, с которым справится ваш компьютер. Некоторые алгоритмы имеют стратегии для более быстрого обрабатывания больших данных, но некоторые будут тормозить. Здесь для наглядности мы будем использовать большой файл.\nВыбирайте любимый:\nmafft --auto 16s_complete.fna &gt; 16s.mafft.fa\n\n# версия muscle 5\nmuscle -align 16s_complete.fna -output 16s.muscle.fa\n# версия muscle 3.8\nmuscle -in 16s_complete.fna -out 16s.muscle.fa\n\nclustalw -INFILE=16s_complete.fna -OUTPUT=FASTA -OUTFILE=16s.clustalw.fa\n\nkalign -i 16s_complete.fna -o 16s.kalign.fa\n\nt_coffee -infile=16s_complete.fna -outfile=16s.tcoffee.fa\n\nprank -d=16s_complete.fna -o=16s.prank.fa\n\n\n\n\n\n\nImportant\n\n\n\n\nMUSCLE - сейчас более доступная для скачивания версия - 5-я. В то же время многие исследователи всё еще используют 3-ю (3.8). У них названия параметров, а некоторых опций, присутствовавших в 3-й версии, уже нет в 5-й версии (см [Добавление к выравниванию новых последовательностей]). Разработчики комментируют это так, что 5-я и 3-я версии - это разные программы: 5-я версия не продолжает 3-ю, а переосмысливает её…\nMAFFT\n\nПараметр --auto говорит программе подобрать стратегию (скорость и точноть) автоматически взависимости от количества входных данных.\nПараметр --maxiteration по умолчанию равен 0. Это количесвто итераций улучшения выравнивания. Для улучшения результата рекомендуется использовать значение 1000. Но учтите, что при большом числе данных результат придется подождать.\nМожно выбрать стратегию самостоятельно. Для подробностей: man mafft\n\nClustalW - по-умолчанию даёт результат в формате .clustal, а не .fasta. Поэтому используется параметр -OUTPUT=FASTA.\nT-coffee и Prank - их работа может занять очень много времени!\n\n\n\n\n\nВизуализация\nДля визуализации выравнивания и нахождения потенциальных проблем “на глаз” мы будем использовать UGENE - биоинформатическиое ПО с графическм интерфейсом, разработанное в Новосибирске.\nЧтобы открыть файл выравнивания нажмём на желтую папку в верхнем левом углу и выберем там соответсвующий файл\n\n\n\n\n\nПосле загрузки мы увидим примерно такую картинку:\n\n\n\nРезультат работы MAFFT\n\n\nПосередине мы увидим непосредственно выровненные последовательности, где нуклеотиды закрашены каждый своим цветом, а пропуски обозначаются символом тире. Слева находятся имена каждой последовательности, которые участвовали в выравнивании.\nСверху столбцы и буквы (нуклеотиды) под ней отражают т.н. консенсусную последовательность - последовательность, содержащая в каждой позиции наиболее часто встречающийся остаток (букву). Таким образом, она представляет собой результат множественного выравнивания.\nВысота столбцов соответствует частоте встречаемости самого частого в данной позиции остатка. Где-то столбцы довольны малы - пропуски в этой позиции составляют большинство. Самые высокие столбцы соответствуют позициям с однозначным выравниванием - здесь вертикальная линия остатков будет, как правило, одного цвета.\nСнизу можно увидеть общую гистограмму таких частот. Об областях, где серая область достигает максимального значения, содно сказать, что они представлены одинаковыми остатками во всех последовательностях. То есть такие “горки” - это наиболее консервативные регионы. “Просадки серости” же говорят о большом количестве пропусков (почти полностью белые области) или высокой вариабельности (серая область пристутсвует, но меньше в несколько раз, чем в консервативных областях) в этом регионе.\n\n\nРезультат\nВидны явно выраженные “горки” консервативных участков и “ямы” V1-V9 участков 16S рРНК. Насколько мы доверяем этому выравнванию? Об этом чуть позже (см. Качество выравнивания).\n\n\nО частых ошибках\n\nПервый капкан\nЗапустим выравнивание для некоторых 10 последовательностей (файл 16s_complete_10.fna)\nmafft --auto 16s_complete_10.fna &gt; 16s.mafft.10.fa\nи визуализируем:\n\n\n\nЧто-то тут не так...\n\n\nОдна последовательность явно выбивается. Проблема на лицо. 9 последовательностей хорошо согласуются друг с другом, 1 из них - плохо, однако все 10 - это один тот же ген. Как такое возможно?\nПричина проста донельзя: проблемная последовательность обратно-комплементарна. Чтобы вернуть ее “истинный вид” нажмите слева на имя проблемной последовательности, потом нажмите на неё правой кнопкой мыши (ПКМ), а затем в разделе Edit &gt; Replace selected rows with reverse-complement. Теперь осталось перевыровнять последовательности. О том, как это сделать прямо в UGENE будет позже (см. Выравнивание не выходя из UGENE).\n\n\n\n\n\n\nNote\n\n\n\nЕсли у вас нет графического интерфейса, то, конечно, вы можете написать и маленький скриптик на питоне, чтобы создать обратно-комплементарную последовательность. Можно даже использовать базовые утилиты терминала:\necho ACCTTGAAA | tr ACGTacgt TGCAtgca | rev \n#TTTCAAGGT\nЕсть и полезные утилиты для работы с последовталеьностями (их надо скачивать отдельно):\nseqtk seq -r seq.fasta &gt; reverse_comp_seq.fasta\n\n\n\n\nВторой капкан\nЗапустим выравнивание c помощью ClustalW для некоторых 4 последовательностей (файл 16s_complete_4.fna)\nclustalw -INFILE=16s_complete_4.fna -OUTPUT=FASTA -OUTFILE=16s.clustalw.4.fa\nВизуализируем…\n\n\n\nЧто это...?\n\n\n4 последовательности были выпотрошены и разбросаны по кускам. Но старым алгоритмам мы доверяем меньше… Попробуем MUSCLE:\nmuscle -align 16s_complete_4.fna -output 16s.muscle.4.fa\n\n\n\nMUSCLE справился лучше, но не без огрех\n\n\nMUSCLE тоже разорвал некоторые последовательности на куски, но не так сильно. Теперь нам ясно в чём проблема. Проблема в частичных вложенных последовательностях, с которыми, при маленьком количестве последовательностей, не все умеют работать.Такие последовательности обычно имеют приписку partial sequence, однако не всегда. Иногда некоторые ленятся уточнить это или считают, что ген был просеквеирован полностью, когда на самом деле лишь часть.\nПопробуем MAFFT\nmafft --auto 16s_complete_4.fna &gt; 16s.mafft.4.fa\n\n\n\nОтлично справился\n\n\nMAFFT справляется с такими случаями лучше всех. Заметка на будущее!"
  },
  {
    "objectID": "practices/msa.html#выравнивание-аминокислотных-последовательностей",
    "href": "practices/msa.html#выравнивание-аминокислотных-последовательностей",
    "title": "Множественное выравнивание",
    "section": "Выравнивание аминокислотных последовательностей",
    "text": "Выравнивание аминокислотных последовательностей\nПринципиально процесс выравнивания аминокислотных последовательностей не отличается от нуклеотидных, поэтому сразу же приступим:\n\nДанные\nМы будем использовать последовталеьность миоглобина у приматов (файл Myoglobin_primates.fna).\nМиоглобин - гемсвязывающий белок скелетных мышц и мышцы сердца. Миоглобин выполняет функцию кислородного резерва, который расходуется, восполняя временную нехватку кислорода при нагрузках.\n\n\n\nМиоглобин. Оранжевым обозначен гем.\n\n\n\n\nЗапускаем программы для выравнивания\nВыбирайте любимый:\nmafft --auto Myoglobin_primates.fna &gt; Myoglobin_primates.mafft.fa\n\n# версия muscle 5\nmuscle -align Myoglobin_primates.fna -output Myoglobin_primates.muscle.fa\n# версия muscle 3.8\nmuscle -in Myoglobin_primates.fna -out Myoglobin_primates.muscle.fa\n\nclustalw -INFILE=Myoglobin_primates.fna -OUTPUT=FASTA -OUTFILE=Myoglobin_primates.clustalw.fa\n\nkalign -i Myoglobin_primates.fna -o Myoglobin_primates.kalign.fa\n\nt_coffee -infile=Myoglobin_primates.fna -outfile=Myoglobin_primates.tcoffee.fa\n\nprank -d=Myoglobin_primates.fna -o=Myoglobin_primates.prank.fa\n\n\n\n\n\n\nNote\n\n\n\nКомментарии по поводу алгоритмов те же, что и для нуклеотидных последовательностей.\n\n\n\n\nВизуализизация\n\n\n\nРезультат работы MAFFT\n\n\nМиоглобин - жизненно необходимый белок и очевидно, что он достаточно консервативен, по крайней мере в тех участках, которые отвечают за связывание гема и кислорода. Один из таких участков выделен на изображении сверху - гистидин (H) в 94-й позиции (у человека). Чтобы белок мог выполнять свою непосредственную функцию область связывания гема должна быть строго постоянна - любое изменение здесь может повлечь серьезную болезнь или даже смерть. Так замена гистидина в 98-й позиции на тирозин (H -&gt; Y) приводит к миоглобинопатии - снижению связывания кислорода и склонности к образованию высокомолекулярных агрегатов (Hofbauer et al. 2022).\nКстати, а где последовательность человека?"
  },
  {
    "objectID": "practices/linux.html",
    "href": "practices/linux.html",
    "title": "Основы Linux",
    "section": "",
    "text": "Important\n\n\n\nUnix – семейство переносимых, многозадачных и многопользовательских операционных систем, которые основаны на идеях оригинального проекта AT&T Unix, разработанного в 1970-х годах в исследовательском центре Bell Labs Кеном Томпсоном и Деннисом Ритчи.\n\n\n\n\n\n\n\n\n\nUnix terminal\n\n\nОсновное отличие Unix-подобных систем от других операционных систем заключается в том, что это изначально многопользовательские многозадачные системы. В Unix может одновременно работать сразу много пользователей, каждый за своим терминалом, при этом каждый из них может выполнять множество различных вычислительных процессов, которые будут использовать ресурсы именно этого компьютера.\nВторое колоссальное преимущество Unix — её мультиплатформенность. Ядро системы разработано таким образом, что его легко можно приспособить практически под любой микропроцессор.\nUnix имеет и другие характерные особенности:\n\nиспользование простых текстовых файлов для настройки и управления системой;\nширокое применение утилит, запускаемых из командной строки;\nвзаимодействие с пользователем посредством виртуального устройства — терминала;\nпредставление физических и виртуальных устройств и некоторых средств межпроцессного взаимодействия в виде файлов;\nиспользование конвейеров из нескольких программ, каждая из которых выполняет одну задачу.\n\nТаким образом, за последние 50 лет Unix-архитектура затронула большую часть технологической индустрии, начиная с вычислительных кластеров, заканчивая macOS и Android (которые так же являются модифицированными версиями Unix). Неудивительно, что и биоинформатику Unix не обошел стороной. Благодаря удобству работы с файлами и создания конвейерных систем обработки данных, мультиплатформенности и многозадачности Unix-системы оказались идеальны для ее задач."
  },
  {
    "objectID": "practices/linux.html#дистрибутивы-linux",
    "href": "practices/linux.html#дистрибутивы-linux",
    "title": "Основы Linux",
    "section": "Дистрибутивы Linux",
    "text": "Дистрибутивы Linux\nБольшинство пользователей для установки Linux используют дистрибутивы, включающие не только набор программ, но и решающие ряд задач по обслуживанию, объединённых едиными системами установки, управления и обновления пакетов, настройки и поддержки.\nСамые распространённые в мире дистрибутивы (2017): Linux Mint, Ubuntu, Debian, Mageia, Fedora, OpenSUSE, ArchLinux, CentOS, PCLinuxOS, Slackware, Gentoo. Многие из дистрибутивов связаны друг с другом и в той или иной степени совместимы, в частности, Ubuntu основан на Debian, а дистрибутивы Mint основаны как на Ubuntu, так и Debian (LMDE) и полностью с ними совместимы, но при этом включают дополнительно поддержку по умолчанию Java, Adobe Flash и некоторых других проприетарных компонентов, а CentOS основан на исходных текстах коммерческого дистрибутива Red Hat Enterprise Linux (доступного в бинарной сборке только платным подписчикам) и при этом полностью бинарно совместимый с ним.\nСамый популярный дистрибутив для использования на серверах, а, соответственно, и на биоинформатических кластерах – Debian."
  },
  {
    "objectID": "practices/linux.html#файловая-система-linux",
    "href": "practices/linux.html#файловая-система-linux",
    "title": "Основы Linux",
    "section": "Файловая система Linux",
    "text": "Файловая система Linux\n\n\n\nДрево файловой системы Linux.\n\n\nВ Unix (и Linux в частности) каждый процесс и в целом, объект, является файлом (даже папка). В отличие от Windows, где дисковое пространство распределяется между разделами, в Linux файловая система представляет собой единое дерево, корневым объектом (папкой) которого является / , также называемый root (не путать с root user). На картинке сверху представлено дерево остальных системных папок Linux и их краткое описание. Обратите внимание, что все они исходят из root.\nПользователь может вносить изменения практически в любой файл системы, хотя это занятие является достаточно опасным и может сломать систему. Безопасной, и по-праву пользовательской папкой является /home и дочерние. В ней для каждого пользователя создается своя домашняя папка."
  },
  {
    "objectID": "practices/linux.html#предисловие",
    "href": "practices/linux.html#предисловие",
    "title": "Основы Linux",
    "section": "Предисловие",
    "text": "Предисловие\n\n\n\nКомандная строка на Mac. Здесь используется командная оболочка OhMyZsh.\n\n\nBash, хоть является популярной, но далеко не единственной командной оболочкой. Большинство команд будут выполнятся одинаково в любой из них, однако, могут быть и различия. Чтобы определить, какая командная оболочка используется в Вашем терминале, можно воспользоваться командой:\necho $0 или echo $SHELL\n\n\n\n\n\n\nWarning\n\n\n\nКоманды в Linux CASE-SENSITIVE.\n\n\nGNU/Linux и многие другие программы являются достаточно хорошо задокументированными проектами. Большинство программ имеют --help параметр, который выведет в терминал документацию. Также для программ GNU доступно руководство с помощью команды man &lt;command-name&gt; .\n\n\n\n\n\n\nTip\n\n\n\nПопробуйте посмотреть документацию и руководство команды echo . (Чтобы выйти из режима руководства - нажмите qq)\n\n\nВыполнение любой команды можно полностью остановить комбинацией клавиш Ctrl-CCtrl-C, а для того, чтобы приостановить – Ctrl-ZCtrl-Z"
  },
  {
    "objectID": "practices/linux.html#взаимодействие-с-файловой-системой",
    "href": "practices/linux.html#взаимодействие-с-файловой-системой",
    "title": "Основы Linux",
    "section": "Взаимодействие с файловой системой",
    "text": "Взаимодействие с файловой системой\n\n\n\n\n\n\nГде я?\n\n\n\n\npwd (print working directory) - выводит на экран путь к текущей активной директории.\nls (list) - показывает содержимое директории.\ndu - выводит информацию об использовании диска файлами и рекурсивно для файлов директорий.\ncd – change directory\ntree - выводит структуру файлового древа директории.\n\n\n\nПуть к файлу - его универсальный идентификатор в файловой системе. Путь может быть как абсолютным – исходящим из корневой папки, так и относительным – из текущей. Чтобы не приходилось постоянно вводить полный путь к файлу, для относительного пути были введены следующие сокращения:\n\n. – текущая директория.\n.. – родительская директория.\n~ – домашняя папка пользователя (/home/&lt;username&gt;)\n/ - корневая папка файлового древа.\n\n\n\n\n\n\n\nРабота с файлами\n\n\n\n\nfile - показать тип файла.\nhead / tail - показать первую/последнюю строку файла.\nless – показать содержимое файла с возможностью скролла.\nstrings – показать все ASCII строки из бинарного файла.\ncat – скопировать из stdin в stdout.\ntac - cat наоборот.\nmkdir - создать папку.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nI/O redirection\n\n\n\n\necho - вывести строку в stdout.\n&lt; - перенаправить stdin.\n&gt; / 1&gt; – перенаправить stdout перезаписывая файл.\n&gt;&gt; / 1&gt;&gt; - перенаправить stdout добавляя строки к файлу.\n2&gt;&gt; – перенаправить stderr добавляя строки к файлу.\n| – создать pipe."
  },
  {
    "objectID": "practices/linux.html#linux-pipelines",
    "href": "practices/linux.html#linux-pipelines",
    "title": "Основы Linux",
    "section": "Linux pipelines",
    "text": "Linux pipelines\n\n\n\n\n\n\n\nПример Linux pipeline.\n\n\nPipeline в Linux перенаправляет вывод одной программы на вход другой.\nПример:\n\nВыводим содержимое файла с помощью cat\nПередаем это утилите grep (grep bmstu - оставить только строки, содержащие bmstu)\nДалее передаем вывод утилите sort (sort -u - отсортировать в алфавитном порядке и оставить только уникальные значения)\n\ncat file.txt | grep bmstu | sort -u"
  },
  {
    "objectID": "practices/linux.html#helpful-shortcuts",
    "href": "practices/linux.html#helpful-shortcuts",
    "title": "Основы Linux",
    "section": "Helpful shortcuts",
    "text": "Helpful shortcuts\n\nСтрелки вверх/вниз – выбрать предыдущую команду.\nCtrl-ACtrl-A – передвинуть курсор на начало команды.\nCtrl-ECtrl-E – передвинуть курсор на конец команды.\nCtrl-CCtrl-C – очистить командную строку.\nTabTab – показать все возможные варианты продолжения команды.\nTab+TabTab+Tab – выбрать первый предложенный вариант продолжения.\nA; B – выполнить A, затем B вне зависимости от успеха выполнения A.\nA && B – выполнить B только в случае успеха A.\nA || B – выполнить B только в случае ошибки/неуспеха A."
  },
  {
    "objectID": "practices/linux.html#общий-вид-команд",
    "href": "practices/linux.html#общий-вид-команд",
    "title": "Основы Linux",
    "section": "Общий вид команд",
    "text": "Общий вид команд\nВсе нижеперечисленные варианты равносильны:\n\n\n\nКоманда\nПараметры\nАргументы\n\n\n\n\nls\n-l --all --human-readable\n./directory\n\n\nls\n-l -a -h\n./directory\n\n\nls\n-lah\n./directory"
  },
  {
    "objectID": "practices/linux.html#работа-с-процессами",
    "href": "practices/linux.html#работа-с-процессами",
    "title": "Основы Linux",
    "section": "Работа с процессами",
    "text": "Работа с процессами\nКак закончить (kill) или приостановить процесс было сказано в разделе Предисловие.\n\nbg N - запустить процесс N в фоне.\nfg N - вернуть процесс N на первый план.\n./script.sh & - запустить скрипт в фоне.\ntop - вывести список всех процессов (диспетчер задач).\nkill PID - закончить процесс по ID.\nkill -9 PID - немедленно прекратить (kill) процесс."
  },
  {
    "objectID": "practices/linux.html#работа-с-файлами-1",
    "href": "practices/linux.html#работа-с-файлами-1",
    "title": "Основы Linux",
    "section": "Работа с файлами",
    "text": "Работа с файлами\n\nReading and editing\n\ncat - вывести содержимое файла в терминал.\nzcat – вывести содержимое сжатого файла в терминал.\nless -S - открыть файл для чтения; qq - выйти, // - поиск, gg - в начало, GG - в конец.\nnano - открыть файл в текстовом редакторе; Ctrl-XCtrl-X - выйти.\n\n\n\nDownloading\n\nwget - скачать по ссылке.\n\n\n\nРабота с архивами\nОдиночный файл:\n\nDecompression:\n\ngunzip -c file.gz &gt; file\ngzip -cd file.gz &gt; file\nunzip -p file.zip &gt; file\n\nCompression\n\ngzip -c file &gt; file.gz\nzip -file file.zip\n\n\nМножественные файлы:\n\nDecompression\n\ntar -xvzf files.tar.gz -C ./\n\nCompression\n\ntar -cvzf files.tar.gz ./*"
  },
  {
    "objectID": "practices/linux.html#sudo",
    "href": "practices/linux.html#sudo",
    "title": "Основы Linux",
    "section": "sudo",
    "text": "sudo\nsudo (англ. Substitute User and do, дословно «подменить пользователя и выполнить») — программа для системного администрирования UNIX-систем, позволяющая делегировать те или иные привилегированные ресурсы пользователям с ведением протокола работы. Основная идея — дать пользователям как можно меньше прав, при этом достаточных для решения поставленных задач. Программа поставляется для большинства UNIX и UNIX-подобных операционных систем.\nКоманда sudo предоставляет возможность пользователям выполнять команды от имени суперпользователя root, либо других пользователей. Правила, используемые sudo для принятия решения о предоставлении доступа, находятся в файле /etc/sudoers (для редактирования файла можно использовать специальный редактор visudo, запускаемый из командной строки без параметров, в том числе без указания пути к файлу).\nВ большинстве случаев грамотная настройка sudo делает небезопасную работу от имени суперпользователя ненужной. Все действия оказываются выполнимы из-под аккаунта пользователя, которому разрешено использовать sudo без ограничений. Имеется возможность запрещать и разрешать определённым пользователям или группам выполнение конкретного набора программ, а также разрешить выполнение определённых программ без необходимости ввода своего пароля."
  },
  {
    "objectID": "practices/linux.html#apt",
    "href": "practices/linux.html#apt",
    "title": "Основы Linux",
    "section": "apt",
    "text": "apt\napt (advanced packaging tool) — программа для установки, обновления и удаления программных пакетов в операционных системах Debian и основанных на них (Ubuntu, Linux Mint и т. п.), иногда также используется в дистрибутивах, основанных на Mandrake, например Mandriva, ALT Linux и PCLinuxOS. Способна автоматически устанавливать и настраивать программы для UNIX-подобных операционных систем как из предварительно откомпилированных пакетов, так и из исходных кодов.\nПакеты берутся из интернет-репозиториев либо их можно установить с имеющихся носителей. Список источников пакетов хранится в файле /etc/apt/sources.list и в каталоге /etc/apt/sources.list.d/. Графические оболочки для apt позволяют легко добавлять новые и удалять ненужные источники.\napt (apt-get) значительно упрощает процесс установки программ в командном режиме.\napt update          Обновление баз данных пакетов (указанных в/etc/apt/sources.list)\napt upgrade         Обновление системы\n\napt search пакет    Поиск пакетов\napt search ^пакет   Поиск пакетов по регулярному выражению\napt show пакет      Поиск пакетов и выводит информацию о пакете\napt install пакет   Установить пакет\n\napt purge пакет     Удалить пакет и его конфигурационные файлы. Возможно использовать для уже удаленного пакета.\napt remove пакет    Удалить пакет\napt autoremove      Удаление всех пакетов-сирот\n\napt autoclean       Очистка кэша неустановленных пакетов\napt clean           Очистка кэша пакетов\n\napt edit-sources    Открывает файл /etc/apt/sources.list в текстовом редакторе для редактирования, после сохранения изменений и закрытия редактора, выполняет проверку файла на предмет ошибок. В случае наличия ошибок, выводит предложение на повторное редактирование файла, чтобы исправить ошибки.\n\napt full-upgrade    Переход от одной основной версии дистрибутива к следующей"
  },
  {
    "objectID": "practices/hmm — копия.html",
    "href": "practices/hmm — копия.html",
    "title": "Введение",
    "section": "",
    "text": "Скрытые Марковские модели"
  },
  {
    "objectID": "practices/hmm — копия.html#предисловие",
    "href": "practices/hmm — копия.html#предисловие",
    "title": "Введение",
    "section": "Предисловие",
    "text": "Предисловие\n\nЧто такое CpG-островки?\nCpG-островки — это специфические участки ДНК с высокой частотой сочетаний цитозина и гуанина (обозначаемых как CpG), которые играют важную роль в регуляции генов. Эти островки часто располагаются рядом с промоторами — участками, ответственными за запуск транскрипции генов, — особенно в геномах эукариот.\n\n\n\n\n\nОдной из ключевых особенностей CpG-островков в промоторных областях является то, что они обычно остаются неметилированными, что способствует активной экспрессии гена. Напротив, их метилирование может приводить к «выключению» гена, подавляя его активность. Поэтому состояние CpG-островков — метилированное или неметилированное — становится своего рода переключателем, который помогает регулировать, будет ли ген экспрессироваться или нет.\n\n\n\n\n\n\n\nКак подготовить HMM?\nМарковская модель описывает систему, которая переходит из одного состояния в другое, причем каждый переход зависит исключительно от текущего состояния (т.н. марковское свойство). Это означает, что будущее состояние системы определяется только ее текущим состоянием, а не всей предшествующей последовательностью событий.\nКлючевые параметры для настройки моделиЖ\n\nСостояния: Определите различные состояния, которые система может занимать. Например, в биоинформатике такие состояния могут представлять биологические признаки, как CpG-островки и некодирующие области генома.\nВероятности переходов: Укажите вероятности перехода из одного состояния в другое. Эти вероятности должны суммироваться до 1 для любого состояния, отражая все возможные пути, которые система может выбрать.\nНачальные вероятности состояний: Задайте вероятности для того, чтобы система начала с определенного состояния. Эти вероятности используются для инициализации модели в начале последовательности.\n\n\n\nКак подготовить HMM. Частный случай.\nСостояния: В этой HMM предусмотрены два состояния — «CpG-островок» и «не-CpG-островок». Состояние CpG-островка представляет области генома с высокой частотой цитозин-гуаниновых динуклеотидов (CG), тогда как состояние не-CpG-островка охватывает стандартные участки генома с низким содержанием CG.\nВероятности перехода: Вероятности перехода между состояниями определяют, какова вероятность перемещения из одного состояния в другое. Например, вероятность остаться в состоянии CpG-островка может быть высокой, что отражает их цельный, локализованный характер. В то же время вероятность перехода из состояния «не-CpG-островок» в «CpG-островок» может быть ниже, так как CpG-островки обычно сконцентрированы в определенных участках генома, часто около промоторных регионов генов.\nВероятности эмиссии: Вероятности эмиссии описывают вероятность наблюдения конкретных нуклеотидов (A, C, G, T) в каждом состоянии. Для CpG-островков характерна более высокая вероятность появления нуклеотидов C и G, что отражает их уникальный состав, тогда как в не-CpG-областях эти вероятности распределены более равномерно.\nМоделирование CpG-островков: Параметры HMM — состояния, вероятности переходов и вероятности эмиссии — создают модель, способную распознать CpG-островки на основе их биологических особенностей, таких как высокое содержание CG и их расположение вблизи промоторных областей. Таким образом, модель не только различает CpG и не-CpG участки, но и выделяет те, что с наибольшей вероятностью играют роль в регуляции генов.\nГрафическое представление: Визуальная схема HMM наглядно отображает модель. В ней состояния представлены узлами, а переходы между ними — стрелками с указанием вероятностей. Такой граф помогает представить, как система переходит между состояниями и в какой последовательности.\nПример работы модели: Рассмотрим гипотетическую последовательность ДНК, чтобы пошагово продемонстрировать работу HMM в определении CpG- и не-CpG-областей. Модель поочередно анализирует каждый нуклеотид и на основе вероятностей эмиссии и переходов «шагает» по состояниям, определяя, где последовательность вероятнее всего является CpG-островком. Такой пошаговый анализ позволяет увидеть, как HMM оценивает данные, выделяя структурные особенности генома."
  },
  {
    "objectID": "practices/hmm — копия.html#алгоритм-витерби",
    "href": "practices/hmm — копия.html#алгоритм-витерби",
    "title": "Введение",
    "section": "Алгоритм Витерби",
    "text": "Алгоритм Витерби\nАлгоритм Витерби — это метод динамического программирования, который позволяет определить наиболее вероятную последовательность скрытых состояний в скрытой марковской модели (HMM) для данной последовательности наблюдаемых событий. Алгоритм вычисляет путь, который максимизирует вероятность наблюдаемой последовательности, путем итеративного расчета наивысшей вероятности для каждого состояния на каждом этапе. При этом сохраняется информация как о вероятностях, так и о «указателях» (backpointer), необходимых для восстановления оптимального пути по завершении расчетов. Благодаря рекурсивному подходу алгоритм эффективно отслеживает путь, ведущий к каждому состоянию, избегая необходимости полного перебора всех возможных путей.\nПочему выбран алгоритм Витерби для данной задачи Алгоритм Витерби особенно подходит для выявления CpG-островков в последовательностях ДНК, так как он позволяет точно расшифровать последовательность в разные состояния (например, «CpG-островок» и «не-CpG-островок») на основе HMM. Высокая вычислительная эффективность делает его идеальным инструментом для анализа длинных последовательностей ДНК, типичных для биоинформатических исследований. Определяя наиболее вероятную последовательность скрытых состояний, алгоритм помогает выявлять биологически значимые области с высоким содержанием CG, что связано с функциями регуляции генов.\nДругие применения алгоритма Витерби Помимо обнаружения CpG-островков, алгоритм Витерби находит широкое применение в различных областях биоинформатики и вычислительной биологии. Например, он используется для предсказания генов, помогая определить расположение экзонов и интронов в геномной последовательности. Алгоритм также применяется в множественном выравнивании последовательностей, где он помогает выровнять родственные биологические последовательности и выявить консервативные регионы. За пределами биоинформатики алгоритм Витерби также используется в системах распознавания речи, языковом моделировании и робототехнике для определения наиболее вероятной последовательности состояний в различных марковских системах."
  },
  {
    "objectID": "practices/hmm — копия.html#имплементация-алгоритма",
    "href": "practices/hmm — копия.html#имплементация-алгоритма",
    "title": "Введение",
    "section": "Имплементация алгоритма",
    "text": "Имплементация алгоритма\nИнициализация матрицы Витерби При работе с алгоритмом Витерби первым шагом является инициализация матрицы, в которой будут храниться вероятности наиболее вероятных путей для каждого состояния на каждом шаге последовательности. Эта матрица позволяет моделировать вероятностный путь через последовательность ДНК, учитывая наиболее вероятные переходы между состояниями.\nИтерация по последовательности В процессе итерации по последовательности ДНК, шаг за шагом, вычисляется вероятность нахождения в каждом из возможных состояний (например, «CpG-островок» или «не-CpG-островок») на каждом этапе последовательности. Этот шаг позволяет постепенно накапливать вероятности, связанные с каждым состоянием в последовательности.\nПостроение и использование матрицы Витерби Создание матрицы Витерби (V): Эта матрица (V) используется для хранения максимальной вероятности достижения каждого состояния в каждый момент последовательности. Дополнительно создается матрица указателей (backpointer), которая сохраняет наиболее вероятное предыдущее состояние для каждого текущего состояния, что будет полезно на этапе определения пути.\nВыбор конечного состояния: В последней колонке матрицы V определяется состояние с наивысшей вероятностью, которое считается конечной точкой на наиболее вероятном пути.\nОбратный проход (backtracking): Начиная с выбранного конечного состояния, матрица указателей используется для «обратного прохода» через последовательность, чтобы восстановить наиболее вероятный путь скрытых состояний. Этот процесс позволяет точно определить участки, такие как CpG-островки, в анализируемой последовательности.\nimport numpy as np\n\n# Example HMM parameters\nstates = ['CpG', 'non-CpG']\nobservations = ['A', 'C', 'G', 'T']\nstate_to_idx = {'CpG': 0, 'non-CpG': 1}\nobs_to_idx = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n\n# Transition probabilities\ntrans_probs = np.array([[0.999, 0.001],  # From CpG\n                        [0.005, 0.995]])  # From non-CpG\n\n# Emission probabilities\nemis_probs = np.array([[0.1, 0.4, 0.4, 0.1],  # CpG\n                       [0.25, 0.25, 0.25, 0.25]])  # non-CpG\n\n# Observed sequence (e.g., 'ACGT')\nobserved_sequence = 'ACGT'\nobs_idx_sequence = [obs_to_idx[nuc] for nuc in observed_sequence]\n\n# Number of states and sequence length\nn_states = len(states)\nseq_len = len(observed_sequence)\n\n# Viterbi matrix to store max probabilities\nV = np.zeros((n_states, seq_len))\n\n# Backpointer matrix to store the best path\nbackpointer = np.zeros((n_states, seq_len), dtype=int)\n\n# Initialization\nfor s in range(n_states):\n    V[s, 0] = emis_probs[s, obs_idx_sequence[0]]\n    backpointer[s, 0] = 0\n\n# Iteration\nfor t in range(1, seq_len):\n    for s in range(n_states):\n        transition_probs = [V[prev_state, t - 1] * trans_probs[prev_state, s] for prev_state in range(n_states)]\n        max_transition_prob = max(transition_probs)\n        V[s, t] = max_transition_prob * emis_probs[s, obs_idx_sequence[t]]\n        backpointer[s, t] = np.argmax(transition_probs)\n\n# Termination: Finding the best last state\nlast_state = np.argmax(V[:, -1])\nbest_path = [last_state]\n\n# Tracking back to find the best path\nfor t in range(seq_len - 1, 0, -1):\n    last_state = backpointer[last_state, t]\n    best_path.append(last_state)\n\n# Reverse the path to get the correct order\nbest_path = best_path[::-1]\n\n# Convert state indices back to state names\nbest_path_states = [states[state] for state in best_path]\n\n# Output the result\nprint(\"Most probable sequence of states:\")\nprint(best_path_states)"
  },
  {
    "objectID": "practices/hmm — копия.html#цель",
    "href": "practices/hmm — копия.html#цель",
    "title": "Введение",
    "section": "Цель",
    "text": "Цель\nНаучиться применять скрытую марковскую модель (HMM) для обнаружения CpG-островков в последовательности ДНК, закрепив теоретические знания, полученные на занятиях."
  },
  {
    "objectID": "practices/hmm — копия.html#задачи",
    "href": "practices/hmm — копия.html#задачи",
    "title": "Введение",
    "section": "Задачи",
    "text": "Задачи\n\nОпределение модели: Задайте HMM с двумя состояниями («CpG» и «не-CpG»), указав разумные начальные значения для вероятностей переходов и эмиссий.\nРеализация алгоритма: Реализуйте алгоритм Витерби на Python для поиска CpG-островков в длинной последовательности ДНК. Этот этап опирается на материал, изученный на занятии, где вы узнали, как применять алгоритм Витерби для нахождения наиболее вероятной последовательности состояний. Теперь ваша задача — применить эти знания к большему и более сложному набору данных.\nОбучение алгоритмом Баум-Велша: Реализуйте алгоритм Баум-Велша для уточнения параметров модели. Этот алгоритм выбран для закрепления навыков, так как он дополняет алгоритм Витерби. В то время как Витерби используется для нахождения наиболее вероятного пути состояний, Баум-Велш позволяет обучать параметры HMM, опираясь исключительно на наблюдаемые данные, когда точные пути состояний неизвестны. Таким образом, студенты получат целостное представление о HMM, переходя от декодирования к оценке параметров. Итогом работы станет способность корректировать вероятности переходов и эмиссий на основе реальных данных, улучшая точность модели.\nВизуализация: Постройте графическое изображение предсказанных CpG-островков (например, с использованием matplotlib). Визуализация позволяет интерпретировать работу модели, наглядно показывая, какие участки последовательности распознаются как CpG-островки.\nАнализ чувствительности параметров: Экспериментируйте с различными начальными значениями для вероятностей переходов и эмиссий и анализируйте, как это влияет на точность предсказаний и сходимость модели. Этот анализ поможет понять, насколько модель чувствительна к начальному выбору параметров, закрепив знания о её устойчивости и стабильности.\nСравнение с реальными данными: Возьмите последовательность ДНК из публичной базы данных (например, NCBI) с известными CpG-островками и проверьте, насколько модель совпадает с существующими аннотациями. Сравнение результатов с реальными данными поможет оценить практическую полезность и точность модели.\nОценка точности: Рассчитайте чувствительность, специфичность и F1-метрику для оценки работы модели, обсудив возможные причины расхождений. Эти метрики помогут количественно оценить точность модели и выявить направления для улучшения.\n\nМатериалы для сдачи:\n\nPython-код: Отправьте документированные скрипты на Python.\nОтчет (3–5 страниц): Подготовьте подробный отчет, включающий описание подхода, трудностей, анализа чувствительности и результатов, а также графики и диаграммы."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Дополнительные главы биоинформатики. 4 Курс.",
    "section": "",
    "text": "Практика 1. Биологические базы данных.\nПрактика 2. GNU/Linux.\nПрактика 3. BLAST\nПрактика 4. Множественное выравнивание последовательностей (MSA)\nПрактика 6. Скрытые марковские модели\n\nДополнительно:\nQ&A по виртуальной машине для практики 2."
  },
  {
    "objectID": "practices/blast.html",
    "href": "practices/blast.html",
    "title": "BLAST",
    "section": "",
    "text": "BLAST (Basic Local Alignment Search Tool) — это разработанный Национальным центром биотехнологической информации (NCBI) мощный набор алгоритмов, используемых для сравнения биологических последовательностей. Сравнение может производиться как между двумя и более вашими последовательностями, так и между вашей последовательностью и выбранной базой данных ДНК, РНК или пептидов. Второй вариант исследователями используется чаще.\nBLAST широко применяется в молекулярной биологии, генетике и эволюционных исследованиях для:\n\nИдентификации неизвестных последовательностей, например, при попадании в образец чужеродной ДНК;\nПоиска гомологичных генов или белков, что позволяет ученым, например, предсказывать функцию генов или белков;\nИзучения эволюционных взаимосвязей между организмами, анализируя различия между гомологичными последовательностями различных организмов."
  },
  {
    "objectID": "practices/blast.html#settings",
    "href": "practices/blast.html#settings",
    "title": "BLAST",
    "section": "Settings",
    "text": "Settings\n\nEnter Query Sequence\nСначала выберем алгоритм из всего зоопарка. Так как наша последовательность состоит из нуклеотидов, то нам нужен, алгоритм, который сравнивает нуклеотидные последовательности - blastn. Затем вставляем в окошко последовательность или, если у вас есть .fasta-файл, то загружаем файл:\n\n\n\n\n\n\nСправа от окошка с последовательностью можно настроить Query subrange - диапазон последовательности, который будет использоваться для поиска, а также снизу Job title - имя запуска, чтобы не запутаться в нескольких запусках и найти потом результат на странице Recent Results (сверху справа под синим баннером и кнопкой Log In).\n\n\n\nChoose Search Set\nИнтерфейс WEB-BLAST позволяет сузить поиск, тем самым ускоряя поиск и заранее отфильтровывая ненужные результаты.\n\n\n\n\n\n\nDatabase\nВо-первых нужно обязательно выбрать базу данных, по которой будет вестись поиск. В зависимости от цели и природы вашей последовательности, выбор базы данных будет отличаться\nВам может быть нужна:\n\nГеномная ДНК\nМитохондриальная ДНК\nВирусная или бактериальная ДНК\nРибосомальная РНК (16S, 18S, 28S)\nСырые данные из секвенатора и др.\n\nПо умолчанию это Core nucleotide database (core_nt) - это курируемая NCBI база данных, которая содержит огромное количество нуклеотидных последовательностей. Она включает в себя базы данных: GenBank, EMBL, DDBJ, PDB, RefSeq и является к тому же Non-redundant, то есть хранит уникальные последовательности, а не нескольких копий одного и того же (по крайней мере очень сильно старается).\n\n\n\n\n\n\nImportant\n\n\n\nОколо выбранной базы данных есть значок вопросительного знака - нажав на него, вы увидете сводную информацию о базе данных. Вообще этот значок есть много где на сайте - смело нажимайте, если что-то не понятно\n\n\n\n\nOrganism\nОпциональным параметром является спецификация taxid: класса, названия семейства, рода, вида или даже организма и прочее. Спецификация таксона значительно сузит и ускорит поиск. По умолчанию поиск будет производиться по всей базе. Если искомый ген есть у многих организмов, то в результате вы их все и получите, но с разной степенью схожести. Иногда исследователю это и нужно - чтобы исследовать различия между организмами.\nПозже на странице полученных результатов их так же можно будет отфильтровать по организму.\n\n\nEnterez Query\nЭто способ применения дополнительных более тонких фильтров поиска в базах данных NCBI (можно использовать при поиске чего угодно в NCBI), таких как BLAST, для уточнения результатов с помощью определенных ключевых слов, полей и логических операторов. Он позволяет сузить поиск до конкретных организмов, диапазонов дат или других аннотаций с помощью специального синтаксиса запроса. Запросы Entrez особенно полезны при поиске в больших базах данных, таких как nr/nt или RefSeq. Но синтаксис там правда иногда жуткий.\nHomo sapiens[organism] AND BRCA1[gene] AND 2020:2024[pdat] - Организм - человек, Ген BRCA1, Информация с 2020 по 2024 год\n\n\n\nProgram Selection\nЗдесь можно выбрать программу оптимизированную под специализированную задачу. В blastn выбор стоит между чувстительностью алгоритмов. В blastp стоит выделить PSI-BLAST (Position-Specific Iterated BLAST), позволяющий более точно обнаруживать гомологи с меньшей степенью сходства, используя итеративный поиск с построением матриц сходства. PHI-BLAST использует для поиска дополнительно данный на вход паттерн поиска, а DELTA-BLAST дополнительно использует в поиске базу данных консервативных последовательностей.\n\n\nP.S.\n\n\n\n\n\n\nWarning\n\n\n\nВ алгоритмах blastx и tblastx есть дополнительный параметр Genetic code. Это важный параметр, если у вас необычный организм или не геномная ДНК (митохондриальная или пластидная). Вы помните про вырожденность и однозначность генетического кода и перевод триплетов (кодонов) в определенную аминокислоту при трансляции в белок из мРНК. Зачем тут что-то выбирать…?\nНо всё не так просто. Даже внутри нас с вами в ядре и митохондрии генетический код различается! Например, в ядерном геноме кодон UGA является стоп-кодоном, а в митохондриальном он кодирует триптофан. Есть и другие различия! Различные огранизмы с разной частотой используют разные сочетания трёх нуклеотидов для одной и той же аминокислоты. Известны и случаи, когда один и тот же кодон играет роль стоп-кодона и кодона, кодирующего аминокислоту. Чтобы учесть подобные нюансы и сделать поиск более точным, важно учесть Genetic code.\n\n\n\n\n\n\n\n\nNote\n\n\n\nПод кнопкой BLAST есть вкладка Algorithm parameters. Если чувствуете себя чересчур крутым, то можете понастраивать алгоритм поиска и выравнивания. Но пока давайте не будем ломать то, что хорошо работает.\n\n\nТеперь мы готовы к запуску! нажимаем заветную кнопку BLAST!"
  },
  {
    "objectID": "practices/blast.html#results",
    "href": "practices/blast.html#results",
    "title": "BLAST",
    "section": "Results",
    "text": "Results\n\nНа странице результатов можно напомнить себе сводную информацию о запуске поиска. Есть возможность отфильтровать результаты по показателям (о них ниже) и организму. Здесь можно увидеть ID задачи, с помощью которой можно будет найти свои результаты в Recent Results.\n\n\n\n\n\n\nCaution\n\n\n\nСоветую сохранить этот ID и учесть, что реузльтаты хранятся на сайте всего 24 часа! Поэтому настоятельно советую их сохранить, если они вам будут нужны позже\n\n\nНу и, конечно, сами результаты. Рассмотрим каждую вкладку результатов.\n\nDescriptions\nСамая главная вкладка результатов, где есть названия последовательностей и значения, по которым можно определить насколько эта последовательность похожа на искомую.\n\nMax score - означает наилучшее локальное выравнивание между нашей последовательностью и найденной\nTotal score - сумма scores всех вариантов глобального выравнивания.\nЕсли Max score = Total score, значит есть лишь один вариант выравнивания и он лучший.\nQuery cover - насколько найденная последовательность совпадает с нашей (покрывает её).\nBit score - нормализованный показатель, позволяющий сравнивать различные поисковые запросы, независимо от размера базы данных или длины запроса.\nРавен \\(\\frac{(λ * Raw Score - \\ln K)}{\\ln 2}\\) , где λ и K - константы, определяемые областью поиска…\nE-value - количество выравниваний с данным или большим score, которые, могут “случайно” совпасть в базе данных.\n\nE-value = длина нашей посл-ти * кол-во нуклеотидов в базе данных / 2 ^ (Bit score)\n\n\n\n\n\n\n\n\nNote\n\n\n\nЧаще всего смотрят именно на этот показатель.\n\n\n\nPer Ident. - Процент совпадений между выравненными последовательностями.\nAccession - уникальный идентификатор, присваиваемый конкретной последовательности в одной из баз данных. Для отслеживания отдельных записей используются регистрационные номера, что облегчает поиск, цитирование и ссылки на конкретные последовательности.\n\n\n\nGraphic summary\nЗдесь визуально представлено то, как выравниваются найденные последовательности на нашу.\n\n\nAlignments\nБолее подробная информация о том, как каждый результат выравнивается на наш запрос - масштаб до нуклеотида. Каждое такое выравнивание можно скачать, визуализировать в геномном браузере. Также здесь есть информация из других баз данных о найденных последовательностях (она не написана тут, но можно перейти по ссылкам).\n\n\nTaxonomy\nЗдесь можно узнать общую информацию о таксономической принадлежности найденных последовательностей."
  },
  {
    "objectID": "practices/blast.html#маленькая-шпаргалка-на-будущее",
    "href": "practices/blast.html#маленькая-шпаргалка-на-будущее",
    "title": "BLAST",
    "section": "Маленькая шпаргалка на будущее",
    "text": "Маленькая шпаргалка на будущее\n\n\n\n\n\n\nTip\n\n\n\n\nНе знаете, какие параметры выбрать? -&gt; Оставляйте по умолчанию\nРезультаты разнородные и их слишком много? -&gt; Отфильтруйте их или в результатах, или установите фильтры при поиске. Подумайте над использованием и другой более узкой базы данных (например, RefSeq).\nРезультатов мало или результат - это название организма и номер хромосомы -&gt; Убедитесь, что с вашей последовательностью всё нормально. Попробуйте использовать более обширную базу данных (например nr/nt). Использовать модифицированный алгоритм: для нуклеотидов - Discontiguous MegaBLAST, для пептидов - PSI-BLAST. Или даже совем другие - tblastx или tblastn - основанные на трансляции в пептиды могут показать более “удаленные” последовательности\n\nBозможно, ваш запрос является некодирующей последовательностью (интрон, межгенная область).\n\nРезультат сомнительный? -&gt; Бывает и так, что вы отправляете на поиск что-то неизведанное! Однако вероятность такого мала, если вы не секвенировали обитателей какой-нибудь Амазонки или Мариансокй впадины. Возможно, ваша последовательность содержит повторы, ошибки. Убедитесь, что вы установили правильные фильтры (особенно на организм)."
  },
  {
    "objectID": "practices/blast.html#итак-что-мы-нашли",
    "href": "practices/blast.html#итак-что-мы-нашли",
    "title": "BLAST",
    "section": "Итак, что мы нашли?",
    "text": "Итак, что мы нашли?\nВ результате мы нашли, что наша последовательность из гена hamlet мушки Drosophila melanogaster.\n\n\n\n\n\n\nNote\n\n\n\nНазван он так в честь фразы Гамлета “to be or not to be”, так как дефект в этом гене влияет на развитие клеток, произошедших от клеток-предшественников “IIB” (созвучно “to be”)\nНорма - IIB, Мутант - not IIB\nГенетики - креативные ребята…"
  },
  {
    "objectID": "practices/blast.html#зачем-запускать-blast-локально-и-создавать-свою-базу-данных-последовательностей",
    "href": "practices/blast.html#зачем-запускать-blast-локально-и-создавать-свою-базу-данных-последовательностей",
    "title": "BLAST",
    "section": "Зачем запускать BLAST локально и создавать свою базу данных последовательностей?",
    "text": "Зачем запускать BLAST локально и создавать свою базу данных последовательностей?\n\nОптимизация производительности\nЛокальный запуск и база данных позволит избежать ограничений, связанных с серверной версией, таких как лимиты на размер последовательности для поиска (100 тыс п.н.) или число запросов. Также, если есть возможность запустить алгоритм на высокопроизводительном сервере, то поиск будет в разы быстрее.\n\n\n\n\n\n\nNote\n\n\n\nПри создании базы данных создаются файлы-индексы, благодаря которым дальнейший поиск по ней происходит намного быстрее (подробнее будет далее).\n\n\nИнтеграция в пайплайн\nИногда запуск BLAST - это лишь один из шагов в большом последовательном автоматизированном анализе. При этом отправка промежуточного результата на веб-версию BLAST неудобна и излишна. К этому еще добавлются и ограниичения из первого пункта.\nПоиск по последовательностям и данным, которых нет в общедоступных базах данных\nНапример, вы изучаете неизвестных человечеству бактерий, геномы которых вы только что расшифровали. Вам очень хочется узнать есть ли в их геномах какая-то последовательность (например, гена, кодирующего токсин). Для этого можно сделать локальную базу данных, содержащую геномы ваших бактерий, а затем произвести по ней поиск уже известной всему миру последовательности гена токсина."
  },
  {
    "objectID": "practices/blast.html#как-создать-локальную-базу-данных-и-запустить-поиск-по-ней",
    "href": "practices/blast.html#как-создать-локальную-базу-данных-и-запустить-поиск-по-ней",
    "title": "BLAST",
    "section": "Как создать локальную базу данных и запустить поиск по ней",
    "text": "Как создать локальную базу данных и запустить поиск по ней\n\nПусть у нас есть .fasta\n#seqs.fasta\n&gt;seq1\nGTACGAGATTACGGCGCATCGATCGATTGCGGATTGCGCGATATATCT\nTAGGCGCTAGCTATATTTTTCGGGAAAAAAGCGCTAGATTCAGCGCGC\nGATCTACATTATATCGACTATTACTAGCGCTATATATATTTATGCGCG\nATTCGCGCTATATCCGAGTATAGAATGCTTAGTCTAGTTCTATCTATT\n&gt;seq2\nACCGGCGATTATATCGGCATGCGACGACATATTATTACGGGCGCCCAT\nATATTCTGCATATATCGCGAAAAATTTTTTGGCCCCGAGGATATATTC\nTCGAGTCTACGATTATATCGGATCGATCAGCAGCTATGCTATCGATCA\nCGAGCACTAGCACAGCTATATATCGCGCATCATAAGATAGCGAAGAGC\n&gt;seq3\nAAAAGGCCCTAGATAGATATATTGCGCATAAAATCGCGGCGCGATCGA\nTCTATATCGATGCGGGAAATTCTCGAGCATCTACGATCATTCATCTAT\nTAAGACGACTAGCATCGAGCACATCACTACTACATAAATTATTCTTTA\nTTCAAATATTTTCTTCAGGGCGATCGATTATCGACGATTATTCTATTT\nи мы хотим найти среди этого всего разнообразия подпоследовательность CTGCATATATTTCGAAAA\n\n\nПопробуем обычный поиск в файле:\ngrep --colour=auto \"CTGCATATATTTCGAAAA\" seqs.fasta #no output\nК сожалению, мы ничего найдем… Вероятно, дело в мутациях. И здесь вступает BLAST:\n\n\nСоздание локальной базы данных\nСначала нужно создать базу данных, по которой будем производить поиск:\nmakeblastdb -in seqs.fasta -dbtype nucl -out databases/db_3_seqs -parse_seqids\n\n-in - наш файл с несколькими записями fasta;\n-dbtype - тип базы данных (nucl - ДНК/РНК, prot - пептиды, белки);\n-out - Это название базы данных. То есть ваша база данных будет храниться в папке databases, а файлы в ней будут с именем db_3_seqs.n**, где n** - это какое-то расширение файла. Далее при использовании BLAST+, если понадобится ИМЯ базы данных, то надо указывать подобное имя (databases/db_3_seqs);\n-parse_seqids - распознать ID последовательностей. Нужно, если -in принимает .fasta и вы хотите сохранить названия записей в файле (&gt;seq1).\nПрочие параметры, которые можно увидеть, если набрать команду makeblastdb -help\n\n\n\n\n\n\n\nTip\n\n\n\nПри запуске этой команды сгенерируется около 10 файлов, поэтому чтобы не захламлять текущую директорию, лучше создать новую.\n\n\n\n\nПоиск!\nТак как поиск будет производиться по нуклеотидным последовательностям, то воспользуемся blastn.\nblastn принимает на вход только файлы, поэтому создадим fasta-файл c искомой последовательностью:\nprintf \"&gt;unknown_seq\\nCTGCATATATTTCGAAAA\" &gt; query.fasta\nА теперь побежали!\nСделаем сразу в двух форматах, чтобы понять разницу\nblastn -query query.fasta -db databases/db_3_seqs -outfmt 7 -word_size=9 &gt; blast_results_fmt6.txt\n\nblastn -query query.fasta -db databases/db_3_seqs -word_size=9 &gt; blast_results_fmt0.txt\n\n-query - файл искомой последовательности;\n-db - созданная нами база данных, по которой ищем;\n-outfmt - формат вывода результата\n\n(их всего 18 видов, о которых можно узнать через blastn -help)\n\n-word_size - алгоритм BLAST устроен так, что сначала он ищет лучшее совпадение “слова” длиной, соответствующей word_size. Если искомая последовательность меньше параметра word_size, то ничего не найдется. У нас достаточно маленькая последовательность, поэтому мы используем своё число.\n\n\n\n\n\n\n\nImportant\n\n\n\nЕсли наша последовательность содержит замены, то word_size, который меньше нашей последовательности не гарантирует, что что-то найдется. Всё дело в заменах, делециях, инсерциях и прочее…\nДопустим у нас последовательтность AGTCGTAA, а ищем мы внутри нее TGGTA. Если выберем word_size=4, то можем ничего не найти! Сначала BLAST пытается выравнить четырёхбуквенные “слова” (TGGT и GGTA) идеально и если не находит ни одного “идеального” совпадения, то результат будет пустым. Теперь установим word_size=3 (TGG, GGT, GTA). И тут мы найдем “идеальное” совпадение:\nAGTCGTAA\nNNNNGTAN\nОтсюда начнется “расширение” поиска алгоритма далее\n\n\n\nО остальных параметрах можно узнать в blastn -help или &lt;another algorithm&gt; -help\n\n\nP.S.\n\n\n\n\n\n\nNote\n\n\n\n\nСуществует также параметр -task, и он принимает значения, о которых можно узнать подробнее отдельно (&lt;algorithm&gt; -help).\n\nВ нашей задаче мог пригодиться “blastn-short\" (\"blastp-short\" - для белков), который сделан специально для поиска коротких последоваталеьностей.\n\nПараметр -remote позволяет отправлять ваши последовательности на NCBI (как WEB-BLAST, но в терминале). Но учтите все ограничения, которые есть у веб-версии! Обратите внимание, что название базы данных после -db нужно указывать то, которое предлагает WEB-BLAST (например, nt). Свою базу данных использовать нельзя.\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nЕсть вариант не создавать базу данных, но рекомендую так делать только если ваша база данных маленькая и/или состоит из коротких последовательностей (например, поиск подпоследовательности в не очень большой последовательности).\nДля этого в алгоритме поиска используйте парамер -subject вместо -db :\n&lt;algorithm&gt; -query query.fasta -subject seqs.fasta  &gt; blast_results_subject.txt\nРезультат будет тот же, но обратите внимание, что здесь мы пишем не навзание базы данных а сразу файл с последовательностями, среди которых ищем. Таким образом, мы пропускаем этап создания базы данных, но на больших данных это сильно замедлит поиск.\n\n\n\n\n\nРезультат\nВыведем на экран реузльтат:\ncat blast_results_fmt6.txt\n# BLASTN 2.16.0+\n# Query: unknown_seq\n# Database: my_db\n# Fields: query acc.ver, subject acc.ver, % identity, alignment length, mismatches, gap opens, q. start, q. end, s. start, s. end, evalue, bit score\n# 1 hits found\nunknown_seq seq2    88.889  18  2   0   1   18  54  71  5.99e-04    23.3\n# BLAST processed 1 queries\ncat blast_results_fmt0.txt\n\nНе буду здесь приводить вывод, потому что он большой, но визуально более понятный!\n\nЧто ж, мы нашли, что наша последовательность была во второй последовательности!\nМы молодцы!\nТеперь мы многое умеем и сможем применить это в самостоятельной работе"
  },
  {
    "objectID": "practices/blast.html#первая-задача",
    "href": "practices/blast.html#первая-задача",
    "title": "BLAST",
    "section": "Первая задача:",
    "text": "Первая задача:\nОпределить имя каждого гена и скачать полную аминокислотную последовательность в формате .fasta.\nДля этого используйте WEB-BLAST. Подумайте каким алгоритмом воспользоваться в случае каждой последовательности и почему.\nВ полученных результатах обращайте внимание на Accessions начинающиеся именно на NM или NP (что это за записи?). В случае NM, нужно найти соответствующую ей запись NP и скачать именно ее. Её можно найти на вебстранице записи NM. Среди нескольких Accessions выбирайте тот, который выше в топе результатов.\n\nПодсказка и напутствие: имя каждого гена должно быть необычным, как hamlet.\nИспользуйте базы данных по-умолчанию\n\nВ качестве ответа на это задание напишите соответствующие названия фрагментов, которые были вам выданы и из название гена, в котором они были найдены."
  },
  {
    "objectID": "practices/blast.html#вторая-задача",
    "href": "practices/blast.html#вторая-задача",
    "title": "BLAST",
    "section": "Вторая задача:",
    "text": "Вторая задача:\nСделать локальную базу данных из найденных аминокислотных последовательностей и найти в ней последовательность из файла unknown_sequence.fasta\nДля этого используйте утилиты makeblastdb и затем соответствующий алгоритм (какой, почему?)\n\nОбратите внимание, добавлять в базу данных последовательность unnamed_sequnce.fa не нужно!\nПодумайте какие параметры можно изменить и почему\n\nВ качестве ответа на это задание напишите название гена, для которого было найден наилучшее совпадение, а также его функцию (найдите в NCBI). Как вы определили. что совпадение наилучшее? Продемострируйте это."
  },
  {
    "objectID": "practices/blast.html#важные-замечания",
    "href": "practices/blast.html#важные-замечания",
    "title": "BLAST",
    "section": "Важные замечания",
    "text": "Важные замечания\n\nЧем подробнее вы напишите отчёт, тем меньше вопросов у нас к нему будет :)\nНе забывайте ответить на попутные вопросы в задачах\nВ первой части не забудьте упомянуть какие параметры используете и почему. Можно привести парочку скринов для каждого вида алгоритма.\nВо второй части приведите код\nЕсли что-то непонятно, то спрашивайте!"
  },
  {
    "objectID": "practices/server-help.html",
    "href": "practices/server-help.html",
    "title": "Q&A по виртуальной машине",
    "section": "",
    "text": "Настройка сетевого адаптера\nЧтобы на виртуальной машине как минимум работала сеть, а также, чтобы к ней можно было подключиться по SSH, в первую очередь необходимо настроить на ней сетевой адаптер. Для этого в VirtualBox:\n\n\n\nОткрываем настройки конфигурации виртуальной машины\n\n\n\n\n\nПереходим на вкладку Network\n\n\n\n\n\nСоздаем (если его нет) сетевые адаптеры\n\n\nНа вкладке Network нужно создать два сетевых адаптера:\n\nNAT\nВнутренняя сеть\n\n\n\nПодключение к ВМ по SSH\nДля подключения к виртуальной машине по SSH выполните следующие шаги:\n\nЗапускаем в VirtualBox нашу виртуальную машину.\nВ консоли виртуальной машины выполняем команду ip a , которая выводит свойства сетевых интерфейсов, в том числе и тот, который нам нужен. Один из адаптеров будет иметь адрес вида 10.0.2.n, где n - произвольное число от 1 до 254, этот адрес нам не интересен, т.к. он недоступен из хостовой машины. Второй имеет адрес вида 192.168.56.n , именно он нам и нужен.\n\nНа собственном компьютере открываем терминал (Win-RWin-R - cmd) и вводим команду:\nssh user@192.168.56.n -p 57022\nn здесь заменяем на число из п. 2.\nПосле исполнения команды нас спросят, доверяем ли мы этому серверу, тк подключаемся к нему в первый раз, мы пишем yes. Затем, нас попросят пароль пользователя, с которым мы подключаемся. для этой машины это user. При вводе пароль не будет отображаться (даже звездочки), это нормально.\nВ терминале появится строка, как на вирт. машине - это значит, что мы подключились и дальнейшие действия будут происходить на ней.\nдля отключения от вирт. машины, вводим команду\nexit"
  },
  {
    "objectID": "practices/db.html",
    "href": "practices/db.html",
    "title": "Биологические базы данных",
    "section": "",
    "text": "Корректный выбор данных является неотъемлемой и зачастую важнейшей частью современных биологических исследований. За последние полвека биология как наука, и методы ее изучения кардинально изменились. Уже в 1982 году была создана первая крупномасштабная база биомедицинских данных GenBank. В 2000 году был закончен “Human Genome Project” – проект по составлению полной последовательности человеческого генома. Над ним несколько лет трудились десятки лабораторий по всему миру. Сейчас же на одном лишь ПК, можно проектировать новые медикаменты, создавать улучшенные сорта растений, выявлять врожденные геномные мутации, проводить эволюционные исследования, моделировать виртуальные биологические системы и многое другое. Все это стало возможно благодаря все растущим биологическим базам данных.\n\n\n\nIncreasing tree of biological databases[@thalor:2019]\n\n\nБиологические данные, собранные человечеством, распределены в десятки (если не сотни) различных баз данных, самой крупной из которых является сервис NCBI - National Center for Biotechnology Information1.\nДля изучения и знакомства со всеми биологическими базами данных вряд ли хватит целой книги, поэтому здесь мы рассмотрим главные из них."
  },
  {
    "objectID": "practices/db.html#базы-данных",
    "href": "practices/db.html#базы-данных",
    "title": "Биологические базы данных",
    "section": "Базы данных",
    "text": "Базы данных\nGoogle Scholar2 – бесплатная поисковая система по научным публикациям, запущенная в ноябре 2004 года. С помощью поисковых роботов портал индексирует метаданные и осуществляет полнотекстовый поиск по научной литературе, включая журнальные статьи, препринты, диссертации, книги и технические отчёты. Пользователи могут искать нужные работы по авторам, ключевым словам, названию журнала. Углублённый поиск позволяет ранжировать материалы по публикации, дате и предметной области.\nАкадемия Google не предоставляет данные о точном количестве проиндексированных работ, однако, по предварительным подсчётам, на 2019 год их было не менее 390 млн. Несмотря на отсутствие достоверных данных о размере базы, портал считается крупнейшей в мире академической поисковой системой, со степенью охвата до 90\n\nGoogle Scholar хотя и является крупнейшей базой данных научных работ, далеко не всегда позволяет найти качественные статьи, поскольку туда попадают любые индексируемые работы, не всегда подвергнутые тщательному ревьюированию.\n\nPubMed3 – бесплатная поисковая система по биомедицинским исследованиям, созданная NCBI в 1997 году. Ежедневно портал посещают около 2,5 млн пользователей.\nPubMed – предоставляет доступ сразу к нескольким базам данных, однако ключевой считается коллекция MEDLINE, содержащая более 30 млн цитирований по естественным, химическим, поведенческим наукам, в том числе по биоинженерии и биофизике. Со временем в PubMed были интегрированы базы данных PreMEDLINE, OLDMEDLINE и книжная коллекция NCBI. PubMed также предоставляет доступ к онлайн-репозиторию PubMed Central.\nДомашняя страница PubMed содержит простое окно поиска и гиперссылки на руководства, инструменты и другие ресурсы. После того как пользователь вводит вопрос, PubMed автоматически уточняет его через систему идентификации MeSH (Medical Subject Headings). Это позволяет проводить наиболее тщательный поиск по всем материалам в связанных базах данных.\n\n\n\nРезультат поискового запроса в PubMed\n\n\nPubMed не хранит полные версии самих статей. Однако если полная версия работы доступна на сайте издательства, то система автоматически генерирует на неё ссылку, даже если статья скрыта за пейволлом. Если полнотекстовая версия размещена в репозитории PubMed Central, ссылка на полный текст появится при отображении её аннотации в PubMed.\n\n\n\nСтраница статьи в PubMed\n\n\n\nВ PubMed индексируются не все существующие биологические журналы. Если поиск не дает результатов, попробуйте Google Scholar, или даже просто Google поиск. Однако начинать все же лучше с PubMed.\n\nbioRxiv (произносится как «биоархив») — бесплатный электронный архив научных статей и препринтов по биологии. Авторы публикуют на bioRxiv ранее не рецензированные работы, чтобы получить фидбэк от других участников портала или утвердить первенство открытия. Перед публикацией рукописи не рецензируются, однако проходят первичную проверку модераторов на плагиат. Около 30 % авторов впоследствии размещают на портале отредактированные с учётом полученных комментариев версии. Большинство представленных на bioRxiv рукописей в результате публикуются в рецензируемых журналах.\nУ любой научной публикации существует DOI (digital object identifier) – цифровой идентификатор объекта, а не идентификатор цифрового объекта. DOI начали использовать с 2000 года, в настоящее время их присваивают более 5000 органов (издательства, центры научных данных, киностудии и другие). Имеется более 100 миллионов имен DOI и более 1,5 миллиарда публикаций DOI в год. DOI порой присваивают и публикациям, созданным задолго до начала его использования."
  },
  {
    "objectID": "practices/db.html#структура-статьи",
    "href": "practices/db.html#структура-статьи",
    "title": "Биологические базы данных",
    "section": "Структура статьи",
    "text": "Структура статьи\n\n\n\nСтандартная структура статей[@article-struct]\n\n\nПочти все статьи структурированы похоже:\n\nTitle - Что исследовали + что получили очень кратко.\nAuthors\nKeywords\nAbstract - Что исследовали + что получили развернуто.\nIntroduction - Введение в проблему и постановка задачи\nMethod - Как исследовали?\nResults - Что получили?\nDiscussion - Какие выводы можно сделать из проведенного исследования?\nConclusion - Итог.\nAcknowledgements\nReferences"
  },
  {
    "objectID": "practices/db.html#как-читать-статьи",
    "href": "practices/db.html#как-читать-статьи",
    "title": "Биологические базы данных",
    "section": "Как читать статьи",
    "text": "Как читать статьи\nЕсли пытаться читать статьи последовательно, как книгу, то данное занятие скорее всего окажется очень утомительным и не слишком продуктивным. Конечно, навык в чтении и понимании статей набирается с опытом, и вырабатываемый метод индивидуален, однако существует несколько основных общих принципов:\n\nВ первую очередь, нужно хорошо сформулировать вопрос, на который вы хотите найти ответ в статьях. Когда он будет готов, можно проводить поиск по ключевым словам, которые его описывают.\nПорядок чтения статьи:\n\nAbstract – подходит ли мне эта статья по содержанию?\nConclusions - являются ли результаты этой статьи существенными в моем вопросе?\nResults - какие именно результаты получили исследователи?\nMaterials and methods – как эти результаты были получены?\n\n\nЕсли на каждом этапе ответ на поставленный вопрос оказывается неудовлетворительным, то скорее всего следует продолжить поиск подходящей литературы.\n\n\n\nimage"
  },
  {
    "objectID": "practices/db.html#типы-данных",
    "href": "practices/db.html#типы-данных",
    "title": "Биологические базы данных",
    "section": "Типы данных",
    "text": "Типы данных\n\nДанные, отражающие фундаментальные знания (aka reference – FASTA, GFF, BED)\nЭкспериментально полученные данные (aka sequencing reads: FASTQ)\nДанные, сгенерированные анализом (aka results: BAM, VCF, other.)[@biostar]\n\n\nFASTA\nFASTA — текстовый формат для нуклеотидных или полипептидных последовательностей, в котором нуклеотиды или аминокислоты обозначаются при помощи однобуквенных кодов. Из-за своей простоты и практичности в настоящее время используется большинством программ работы с биологическими последовательностями. Файлы данного формата могут содержать названия последовательностей, их идентификаторы в базах данных и комментарии. В зависимости от природы содержащихся в нем биологических последовательностей файл формата FASTA может иметь различные расширения.\nРасширения – .fa, .fasta, .fna.\n\n\n\nimage\n\n\n\n\nFASTQ\nФормат FASTQ — текстовый формат данных, используемый для представления биологической последовательности (обычно нуклеотидной последовательности) и показателей качества каждого элемента последовательности. Элементы последовательности и их показатели качества кодируются для краткости одиночными символами ASCII.\n\n\n\nimage\n\n\n\n\nGFF/GTF/BED\nФорматы GFF/GTF/BED - это так называемые «интервальные» форматы, в которых сохраняются только координаты региона в геноме. Каждый из них разграничен табуляцией и содержит информацию о хромосомной координате, начале, конце, нить, значении и других атрибутах, хотя порядок столбцов зависит от формата.\nТрехстолбцовый BED содержит информацию о хромосоме, начале и конце региона.\n\n\n\nimage\n\n\nШестистолбцовый BED также содержит название региона, значение какой-либо характеристики (depends…) и нить ДНК.\n\n\n\nimage\n\n\nGFF/GTF форматы имеют 9 столбцов, их спецификацию можно найти на сайте UCSC4.\n\n\n\nimage\n\n\n\n\nSAM/BAM\nSequence Alignment Map5 (SAM) - текстовый формат для хранения биологических последовательностей, выровненных относительно референсной последовательности. Он широко используется для хранения данных, таких как нуклеотидные последовательности, генерируемые технологиями NGS.\nBinary Alignment Map (BAM) - бинарная версия SAM.\n\n\n\nimage\n\n\n\n\nVCF\nVariant Call Format6 (VCF) - это стандартный формат текстовых файлов, используемый в биоинформатике для хранения вариаций генных последовательностей.\n\n\n\nimage"
  },
  {
    "objectID": "practices/db.html#базы-данных-1",
    "href": "practices/db.html#базы-данных-1",
    "title": "Биологические базы данных",
    "section": "Базы данных",
    "text": "Базы данных\nINSDC7 (International Nucleotide Sequence Database Collaboration) – коллаборация организаций осуществляющая хранение “основных” геномных данных. Участниками организации являются:\n\nNCBI8: National Center for Biotechnology Information\nEMBL9: European Molecular Biology Laboratory\nDDBJ10: DNA Data Bank of Japan\n\nINSDC установил правила в отношении типов данных, которые будут копироваться. Наиболее важными из них с точки зрения биоинформатика являются:\n\nGenBank\nGenBank11 содержит всю аннотированную и идентифицированную информацию о последовательности ДНК.\n\n\n\nimage\n\n\n\n\nSRA\nSRA12: Short Read Archive содержит данные, полученные в ходе высокопроизводительного секвенирования.\n\n\n\nimage\n\n\n\n\nUniProt\nUniProt13: Universal Protein Resource хранилище данных о последовательности и характеристиках белков.\n\n\n\nimage\n\n\n\n\nPDB\nProtein Data Bank14 (PDB) является основным хранилищем структурной информации о биологических макромолекулах (белках и нуклеиновых кислотах). PDB содержит структуры для целого спектра биомолекул - от небольших кусочков белков/нуклеиновых кислот до сложных молекулярных структур, таких как рибосомы.\n\n\n\n\nThree-dimensional structure of BOMBYXIN-II\n\n\n\n\n\nCryo-EM structure of a yeast pre-40S ribosomal subunit\n\n\n\n3D-структуры белков из PDB\n\n\n\n\nNotable mentions\n\nUCSC Genome Browser15 - предлагает подробные данные о геномах млекопитающих, а также утилиту для их просмотра.\nRNA-Central16 – мета-база данных, объединяющая информацию из нескольких других ресурсов.\nEnsembl17 — совместный научный проект Европейского института биоинформатики и Института Сенгера. Основной задачей этого проекта является обеспечение специалистов интегрированным доступом к базам данных, касающихся строения геномов более 50 видов позвоночных, включая человека (Homo sapiens), мышь (Mus musculus), крысу (Rattus norvegicus), рыбку Данио-рерио (Danio rerio) и др. Базы данных Ensembl регулярно обновляются с частотой не менее двух раз в год.\nFlyBase18 - это база данных генов и геномов дрозофилы (плодовой мушки).\nWormBase19 - это основной ресурс по биологии нематод.\nSGD20: Saccharomyces Genome Database предоставляет всестороннюю биологическую информацию о дрожжах Saccharomyces cerevisiae, а также инструменты поиска и анализа для изучения этих данных.\nTAIR21 The Arabidopsis Information Resource - это основной ресурс генетических и молекулярных данных о модельном растении Arabidopsis thaliana.\nEcoCyc22 (Encyclopedia of E. coli Genes and Metabolic Pathways) - это научная база данных о бактерии Escherichia coli K-12 MG1655.\nGeneCards23 - это интегративная база данных с возможностью поиска, которая предоставляет полную и удобную для пользователя информацию обо всех аннотированных и предсказанных генах человека. База данных автоматически объединяет данные из  150 веб-источников, включая геномную, транскриптомную, протеомную, генетическую, клиническую и функциональную информацию.\nMGI24: (Mouse Genome Informatics) собирает и хранит всесторонние фенотипы и функциональные аннотации для генов и аллелей мыши."
  },
  {
    "objectID": "practices/db.html#сборки-геномов",
    "href": "practices/db.html#сборки-геномов",
    "title": "Биологические базы данных",
    "section": "Сборки геномов",
    "text": "Сборки геномов\nРеференсный геном (референсная сборка) - это цифровая база данных последовательностей нуклеиновых кислот, собранная учеными как репрезентативный пример набора генов в одном идеализированном индивидуальном организме какого-либо вида. Поскольку они собираются на основе секвенирования ДНК нескольких индивидуальных доноров, референсные геномы не могут представлять точный набор генов какого-либо отдельного организма. Вместо этого эталон представляет собой гаплоидную мозаику из различных последовательностей ДНК от каждого донора. Например, один из самых последних референсных геномов человека, сборка GRCh38/hg38, получена из &gt;60 библиотек геномных клонов. Существуют референсные геномы для множества видов вирусов, бактерий, грибов, растений и животных. Референсные геномы обычно используются в качестве основы для выравнивания чтений других геномов, что позволяет собирать их гораздо быстрее и дешевле, чем в рамках первоначального проекта «Геном человека». Доступ к референсным геномам можно получить онлайн в нескольких базах данных, используя специальные браузеры, такие как Ensembl или UCSC Genome Browser.\nСколько существует сборок человеческого генома? 38 на данный момент. Увы, существуют не только различные геномные сборки, но и различные ресурсы по распространению данных могут расходиться во мнениях относительно того, как маркировать одни и те же данные.\n\n\n\nСравнение геномных аннотаций сделанных GENCODE, Ensemble, RefSeq\n\n\nHuman Gene Nomenclature Committee25 (HGNC) является единственной организацией, которая присваивает стандартную номенклатуру генам человека. Названия, присваиваемые HGNC, обычно формируются из так называемого корневого (stem) символа, который используется в качестве основы для серии утвержденных символов, которые определяются как члены функционального или структурного семейства генов. Например, CYP: cytochrome P450; HOX: homeobox; DUSP: dual specificity phosphatase; SCN2A: sodium channel voltage-gated type II alpha 2 polypeptides и т. д."
  },
  {
    "objectID": "practices/db.html#genome-browsers",
    "href": "practices/db.html#genome-browsers",
    "title": "Биологические базы данных",
    "section": "Genome browsers",
    "text": "Genome browsers\nГеномный браузер - это графический интерфейс для отображения информации из базы геномных данных. Большинство геномных браузеров рисуют дорожки, представляющие прямую нить генома в направлении от 5’ (слева) к 3’ (справа). Геномные признаки, нарисованные на этой линейной дорожке, называются глифами. Глиф - это пиктограмма, соответствующая определенной геномной характеристике. Универсального стандарта, определяющего все инструменты визуализации, не существует. Интерпретация глифов приходит с опытом и уровнем знакомства с каждым инструментом. Например, здесь представлен снимок экрана по умолчанию геномного браузера UCSC:\n\n\n\nИнтерфейс UCSC Genome Browser\n\n\nВ большинстве случаев геномные браузеры работают только с данными в простых форматах: FASTA, BED, GFF, SAM/BAM. Форматы данных, содержащие более сложную информацию, такие как GenBank или EMBL, обычно нуждаются в преобразовании и упрощении в линейно-ориентированный формат, например BED или GFF. Большинство инструментов визуализации поставляются с предварительно загруженными данными, а также с различными геномными сборками для широко используемых организмов: человека, мыши и т. д. Это означает, что данные для многих геномных характеристик, скорее всего, уже имеются. Для других организмов зачастую требуется самостоятельно загружать данные в браузер.\n\n\nCaption\n\n\nStandalone\nOnline\n\n\nIGV (Integrative Genomic Viewer)\nUCSC Genome/Table Browser\n\n\nJBrowse2\nEnsembl Genome Browser\n\n\nGenoverse\nNCBI Genome Data Viewer\n\n\n\n\n\nИнтерпретация глифов\nГлифы - это визуальное представление некоторых геномных характеристик:\n\nГоризонтальные интервалы: направления, гены, выравнивания\nЗначения через интервалы: покрытия, вероятности\nАтрибуты в местах расположения: мутации, делеции, и т.д.\n\nНа рисунке показан пример такого отображения для геномного браузера NCBI Genome Data Viewer (показан ген HBB бета-цепи гемоглобина человека):\n\n\n\nimage\n\n\nТранскрипты схематически изображаются в виде соединенных линиями прямоугольников. Прямоугольники соответствуют экзонам гена, а закрашенная (темно-зеленая) область в прямоугольниках соответствует белок-кодирующей последовательности. Линии, соединяющие прямоугольники, соответствуют интронам. Слева от транскриптов указаны их идентификаторы, а справа – идентификаторы соответствующих им белковых продуктов.\nИдентификаторы (Accession number) белок-кодирующих мРНК-транскриптов в базе данных RefSeq начинаются с префикса “NM_”. RefSeq содержит также файлы соответствующих транскриптам белковых продуктов (их последовательность определяется по открытой рамке считывания в транскрипте), они имеют идентификаторы с префиксом “NP_”. Теоретически предсказываемые мРНК-транскрипты (имеющие статус “predicted” или “model”) и соответствующие им белковые продукты имеют идентификаторы с префиксами “XM_” и “XP_” соответственно.\nДля указания хромосомной локализации гена (т.н. хромосомного локуса) используется следующая система обозначения. Локус записывается в виде\n\\(N[p/q]RB.S\\)\nгде N – номер хромосомы, p или q – обозначают короткое или длинное плечо хромосомы (от фр. petit – “малый”, queue – “хвост”), R – номер области (region), B – номер зоны (band), S – номер подзоны (sub-band). Пример локуса для гена альбумина (ALB) – 4q13.3. Зоны в данном случае соответствуют цитогенетическим зонам, получаемым при G-окрашивании хромосом красителем. Такое окрашивание используется для определения кариотипа, поскольку распределение темных (гетерохроматин) и светлых (эухроматин) полос позволяет однозначно идентифицировать хромосомы:\n\n\n\nНормальный кариотип человечека."
  },
  {
    "objectID": "practices/db.html#footnotes",
    "href": "practices/db.html#footnotes",
    "title": "Биологические базы данных",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://www.ncbi.nlm.nih.gov↩︎\nhttps://scholar.google.com↩︎\nhttps://pubmed.ncbi.nlm.nih.gov↩︎\nhttps://genome.ucsc.edu/FAQ/FAQformat.html↩︎\nhttps://samtools.github.io/hts-specs/SAMv1.pdf↩︎\nhttps://samtools.github.io/hts-specs/VCFv4.2.pdf↩︎\nhttp://www.insdc.org/↩︎\nhttp://www.ncbi.nlm.nih.gov/↩︎\nhttp://www.embl.org/↩︎\nhttp://www.ddbj.nig.ac.jp/↩︎\nhttp://www.ncbi.nlm.nih.gov/genbank/↩︎\nhttp://www.ncbi.nlm.nih.gov/sra↩︎\nhttp://www.uniprot.org/↩︎\nhttp://www.rcsb.org/pdb/home/home.do↩︎\nhttps://genome.ucsc.edu↩︎\nhttps://rnacentral.org↩︎\nhttp://www.ensembl.org↩︎\nhttp://flybase.org/↩︎\nhttps://www.wormbase.org↩︎\nhttp://www.yeastgenome.org/↩︎\nhttps://www.arabidopsis.org/↩︎\nhttp://ecocyc.org/↩︎\nhttps://www.genecards.org↩︎\nhttp://www.informatics.jax.org/↩︎\nhttp://www.genenames.org/↩︎"
  }
]