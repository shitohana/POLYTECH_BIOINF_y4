<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.56">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>hmm – POLYTECH_BIOINF_y4</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="../site_libs/quarto-diagram/mermaid.min.js"></script>
<script src="../site_libs/quarto-diagram/mermaid-init.js"></script>
<link href="../site_libs/quarto-diagram/mermaid.css" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">POLYTECH_BIOINF_y4</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#введение" id="toc-введение" class="nav-link active" data-scroll-target="#введение">Введение</a></li>
  <li><a href="#практическое-задание" id="toc-практическое-задание" class="nav-link" data-scroll-target="#практическое-задание">Практическое задание</a>
  <ul class="collapse">
  <li><a href="#как-подготовить-hmm" id="toc-как-подготовить-hmm" class="nav-link" data-scroll-target="#как-подготовить-hmm">Как подготовить HMM?</a></li>
  <li><a href="#предисловие" id="toc-предисловие" class="nav-link" data-scroll-target="#предисловие">Предисловие</a>
  <ul class="collapse">
  <li><a href="#что-такое-cpg-островки" id="toc-что-такое-cpg-островки" class="nav-link" data-scroll-target="#что-такое-cpg-островки">Что такое CpG-островки?</a></li>
  </ul></li>
  <li><a href="#алгоритм-витерби-reminder" id="toc-алгоритм-витерби-reminder" class="nav-link" data-scroll-target="#алгоритм-витерби-reminder">Алгоритм Витерби (reminder)</a>
  <ul class="collapse">
  <li><a href="#как-подготовить-hmm.-частный-случай." id="toc-как-подготовить-hmm.-частный-случай." class="nav-link" data-scroll-target="#как-подготовить-hmm.-частный-случай.">Как подготовить HMM. Частный случай.</a></li>
  </ul></li>
  <li><a href="#имплементация-алгоритма" id="toc-имплементация-алгоритма" class="nav-link" data-scroll-target="#имплементация-алгоритма">Имплементация алгоритма</a>
  <ul class="collapse">
  <li><a href="#входные-данные" id="toc-входные-данные" class="nav-link" data-scroll-target="#входные-данные">Входные данные:</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#оценка-эффективности-модели" id="toc-оценка-эффективности-модели" class="nav-link" data-scroll-target="#оценка-эффективности-модели">Оценка эффективности модели</a>
  <ul class="collapse">
  <li><a href="#sensitivity-and-specificity" id="toc-sensitivity-and-specificity" class="nav-link" data-scroll-target="#sensitivity-and-specificity">Sensitivity and specificity</a></li>
  <li><a href="#f-score" id="toc-f-score" class="nav-link" data-scroll-target="#f-score">F-score</a>
  <ul class="collapse">
  <li><a href="#определения" id="toc-определения" class="nav-link" data-scroll-target="#определения">Определения</a></li>
  <li><a href="#параметр-beta" id="toc-параметр-beta" class="nav-link" data-scroll-target="#параметр-beta">Параметр <span class="math inline">\(\beta\)</span></a></li>
  <li><a href="#применение-f-score" id="toc-применение-f-score" class="nav-link" data-scroll-target="#применение-f-score">Применение F-score</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#домашнее-задание" id="toc-домашнее-задание" class="nav-link" data-scroll-target="#домашнее-задание">Домашнее задание</a>
  <ul class="collapse">
  <li><a href="#цель" id="toc-цель" class="nav-link" data-scroll-target="#цель">Цель</a></li>
  <li><a href="#задачи" id="toc-задачи" class="nav-link" data-scroll-target="#задачи">Задачи</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">




<p>Скрытые Марковские модели</p>
<section id="введение" class="level1">
<h1>Введение</h1>
<p>HMM (Hidden Markov Models, Скрытые марковские модели) – это мощные статистические методы, позволяющие моделировать биологические последовательности и выявлять скрытые стохастические процессы, которые управляют их формированием.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="_files/hmm/hmm_scheme.jpeg" class="img-fluid quarto-figure quarto-figure-center figure-img" alt="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fm.youtube.com%2Fwatch%3Fv%3DRWkHJnFj5rY&amp;psig=AOvVaw18rQYPNv-xvGZq_2Gi1Trd&amp;ust=1731420593170000&amp;source=images&amp;cd=vfe&amp;opi=89978449&amp;ved=0CBcQjhxqFwoTCNDK3ry61IkDFQAAAAAdAAAAABAT"></p>
</figure>
</div>
<p>В биоинформатике HMM используются для анализа последовательностей, предсказания генов и обнаружения мотивов. Они особенно полезны в задачах, связанных с последовательными данными, где скрытые состояния (такие как, например, кодирующие и некодирующие регионы) оказывают влияние на наблюдаемые события (например, нуклеотидные последовательности).</p>
<p>HMM широко применяются для предсказания генов, помогая определить кодирующие участки ДНК и, таким образом, позволяют продолжить изучение структуры и функции генов. Они также используются в множественном выравнивании последовательностей, что помогает сопоставлять родственные последовательности и изучать эволюционные взаимосвязи.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="_files/hmm/hmm_scheme_seq.jpeg" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
</section>
<section id="практическое-задание" class="level1">
<h1>Практическое задание</h1>
<p>Данное практическое занятие будет посвящено применению HMM для поиска CpG-островков в геноме.</p>
<section id="как-подготовить-hmm" class="level3">
<h3 class="anchored" data-anchor-id="как-подготовить-hmm">Как подготовить HMM?</h3>
<p>Марковская модель описывает систему, которая переходит из одного состояния в другое, причем каждый переход зависит исключительно от текущего состояния (т.н. марковское свойство). Это означает, что будущее состояние системы определяется только ее текущим состоянием, а не всей предшествующей последовательностью событий.</p>
<p>Ключевые параметры для настройки модели:</p>
<ul>
<li><p>Состояния: Определите различные состояния, которые система может занимать.</p></li>
<li><p>Вероятности переходов: Укажите вероятности перехода из одного состояния в другое. Эти вероятности должны суммироваться до 1 для любого состояния, отражая все возможные пути, которые система может выбрать.</p></li>
<li><p>Начальные вероятности состояний: Задайте вероятности для того, чтобы система начала с определенного состояния. Эти вероятности используются для инициализации модели в начале последовательности.</p></li>
</ul>
</section>
<section id="предисловие" class="level2">
<h2 class="anchored" data-anchor-id="предисловие">Предисловие</h2>
<section id="что-такое-cpg-островки" class="level3">
<h3 class="anchored" data-anchor-id="что-такое-cpg-островки">Что такое CpG-островки?</h3>
<p>CpG-островки — это специфические участки ДНК с высокой частотой сочетаний цитозина и гуанина (обозначаемых как CpG), которые играют важную роль в регуляции генов. Эти островки часто располагаются рядом с промоторами — участками, ответственными за запуск транскрипции генов, — особенно в геномах эукариот.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="_files/hmm/cpg_island.jpeg" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p>Одной из ключевых особенностей CpG-островков в промоторных областях является то, что они обычно остаются неметилированными, что способствует активной экспрессии гена. Напротив, их метилирование может приводить к «выключению» гена, подавляя его активность. Поэтому состояние CpG-островков — метилированное или неметилированное — становится своего рода переключателем, который помогает регулировать, будет ли ген экспрессироваться или нет.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="_files/hmm/cpg_island2.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="background-color: white"></p>
</figure>
</div>
</section>
</section>
<section id="алгоритм-витерби-reminder" class="level2">
<h2 class="anchored" data-anchor-id="алгоритм-витерби-reminder">Алгоритм Витерби (reminder)</h2>
<p>Алгоритм Витерби — это метод динамического программирования, который позволяет определить наиболее вероятную последовательность скрытых состояний в скрытой марковской модели (HMM) для данной последовательности наблюдаемых событий. Алгоритм вычисляет путь, который максимизирует вероятность наблюдаемой последовательности, путем итеративного расчета наивысшей вероятности для каждого состояния на каждом этапе. При этом сохраняется информация как о вероятностях, так и о «указателях» (backpointer), необходимых для восстановления оптимального пути по завершении расчетов. Благодаря рекурсивному подходу алгоритм эффективно отслеживает путь, ведущий к каждому состоянию, избегая необходимости полного перебора всех возможных путей.</p>
<p>Почему выбран алгоритм Витерби для данной задачи? Алгоритм Витерби особенно подходит для выявления CpG-островков в последовательностях ДНК, так как он позволяет точно расшифровать последовательность в разные состояния (например, «CpG-островок» и «не-CpG-островок») на основе HMM. Высокая вычислительная эффективность делает его идеальным инструментом для анализа длинных последовательностей ДНК, типичных для биоинформатических исследований. Определяя наиболее вероятную последовательность скрытых состояний, алгоритм помогает выявлять биологически значимые области с высоким содержанием CG, что связано с функциями регуляции генов.</p>
<p>Aлгоритм Витерби находит широкое применение в различных областях биоинформатики и вычислительной биологии. Например, он используется для предсказания генов, помогая определить расположение экзонов и интронов в геномной последовательности. Алгоритм также применяется в множественном выравнивании последовательностей, где он помогает выровнять родственные биологические последовательности и выявить консервативные регионы. За пределами биоинформатики алгоритм Витерби также используется в системах распознавания речи, языковом моделировании и робототехнике для определения наиболее вероятной последовательности состояний в различных марковских системах.</p>
<section id="как-подготовить-hmm.-частный-случай." class="level3">
<h3 class="anchored" data-anchor-id="как-подготовить-hmm.-частный-случай.">Как подготовить HMM. Частный случай.</h3>
<p>Состояния: В этой HMM предусмотрены два состояния — «CpG-островок» и «не-CpG-островок». Состояние CpG-островка представляет области генома с высокой частотой цитозин-гуаниновых динуклеотидов (CG), тогда как состояние не-CpG-островка охватывает стандартные участки генома с низким содержанием CG.</p>
<p>Вероятности перехода: Вероятности перехода между состояниями определяют, какова вероятность перемещения из одного состояния в другое. Например, вероятность остаться в состоянии CpG-островка может быть высокой, что отражает их цельный, локализованный характер. В то же время вероятность перехода из состояния «не-CpG-островок» в «CpG-островок» может быть ниже, так как CpG-островки обычно сконцентрированы в определенных участках генома, часто около промоторных регионов генов.</p>
<p>Вероятности эмиссии: Вероятности эмиссии описывают вероятность наблюдения конкретных нуклеотидов (A, C, G, T) в каждом состоянии. Для CpG-островков характерна более высокая вероятность появления нуклеотидов C и G, что отражает их уникальный состав, тогда как в не-CpG-областях эти вероятности распределены более равномерно.</p>
<p>Моделирование CpG-островков: Параметры HMM — состояния, вероятности переходов и вероятности эмиссии — создают модель, способную распознать CpG-островки на основе их биологических особенностей, таких как высокое содержание CG и их расположение вблизи промоторных областей. Таким образом, модель не только различает CpG и не-CpG участки, но и выделяет те, что с наибольшей вероятностью играют роль в регуляции генов.</p>
<p>Графическое представление: Визуальная схема HMM наглядно отображает модель. В ней состояния представлены узлами, а переходы между ними — стрелками с указанием вероятностей. Такой граф помогает представить, как система переходит между состояниями и в какой последовательности.</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">stateDiagram-v2
    [*] --&gt; NonCpG

    state "Non-CpG" as NonCpG
    state "CpG Island" as CpG

    NonCpG --&gt; NonCpG : p = 0.999
    NonCpG --&gt; CpG : p = 0.001
    CpG --&gt; CpG : p = 0.995
    CpG --&gt; NonCpG : p = 0.005

    note right of NonCpG
        **Emission Probabilities:**
        A: 0.30
        C: 0.20
        G: 0.20
        T: 0.30
    end note

    note left of CpG
        **Emission Probabilities:**
        A: 0.15
        C: 0.35
        G: 0.35
        T: 0.15
    end note

</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
</section>
</section>
<section id="имплементация-алгоритма" class="level2">
<h2 class="anchored" data-anchor-id="имплементация-алгоритма">Имплементация алгоритма</h2>
<p>Инициализация матрицы Витерби При работе с алгоритмом Витерби первым шагом является инициализация матрицы, в которой будут храниться вероятности наиболее вероятных путей для каждого состояния на каждом шаге последовательности. Эта матрица позволяет моделировать вероятностный путь через последовательность ДНК, учитывая наиболее вероятные переходы между состояниями.</p>
<p>Итерация по последовательности В процессе итерации по последовательности ДНК, шаг за шагом, вычисляется вероятность нахождения в каждом из возможных состояний (например, «CpG-островок» или «не-CpG-островок») на каждом этапе последовательности. Этот шаг позволяет постепенно накапливать вероятности, связанные с каждым состоянием в последовательности.</p>
<p>Построение и использование матрицы Витерби Создание матрицы Витерби (V): Эта матрица (V) используется для хранения максимальной вероятности достижения каждого состояния в каждый момент последовательности. Дополнительно создается матрица указателей (backpointer), которая сохраняет наиболее вероятное предыдущее состояние для каждого текущего состояния, что будет полезно на этапе определения пути.</p>
<p>Выбор конечного состояния: В последней колонке матрицы V определяется состояние с наивысшей вероятностью, которое считается конечной точкой на наиболее вероятном пути.</p>
<p>Обратный проход (backtracking): Начиная с выбранного конечного состояния, матрица указателей используется для «обратного прохода» через последовательность, чтобы восстановить наиболее вероятный путь скрытых состояний. Этот процесс позволяет точно определить участки, такие как CpG-островки, в анализируемой последовательности.</p>
<p>Пример имплементации алгоритма (псевдокод)</p>
<section id="входные-данные" class="level3">
<h3 class="anchored" data-anchor-id="входные-данные">Входные данные:</h3>
<ul>
<li><span class="math inline">\(O = {o_1, o_2, \dots, o_N}\)</span>: Пространство наблюдений</li>
<li><span class="math inline">\(S = {s_1, s_2, \dots, s_K}\)</span>: Пространство состояний</li>
<li><span class="math inline">\(Y = {y_1, y_2, \dots, y_T}\)</span>: Последовательность наблюдений</li>
<li><span class="math inline">\(A\)</span>: Матрица переходов из <span class="math inline">\(i\)</span>-го состояния в <span class="math inline">\(j\)</span>-е, размером <span class="math inline">\(K \times K\)</span></li>
<li><span class="math inline">\(B\)</span>: Матрица эмиссии размера <span class="math inline">\(K \times N\)</span>, определяющая вероятность наблюдения <span class="math inline">\(o_j\)</span> из состояния <span class="math inline">\(s_i\)</span></li>
<li><span class="math inline">\(\pi\)</span>: Массив начальных вероятностей размером <span class="math inline">\(K\)</span>, показывающий вероятность того, что начальное состояние — <span class="math inline">\(s_i\)</span></li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">Viterbi</span>(O, S, P, Y, A, B) </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="ot">=</span> <span class="dv">1</span> to K</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        TState[j, <span class="dv">1</span>] <span class="ot">=</span> P[j] <span class="sc">*</span> B[j, Y[<span class="dv">1</span>]]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        TIndex[j, <span class="dv">1</span>] <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="ot">=</span> <span class="dv">2</span> to T</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="ot">=</span> <span class="dv">1</span> to K</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>            TIndex[j, i] <span class="ot">=</span> <span class="fu">argmax_k_in_K</span> (TState[k, i<span class="dv">-1</span>] <span class="sc">*</span> A[k, j] <span class="sc">*</span> B[j, Y[i]])</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>            TState[j, i] <span class="ot">=</span> TState[TIndex[j, i], i<span class="dv">-1</span>] <span class="sc">*</span> A[TIndex[j, i], j] <span class="sc">*</span> B[j, Y[i]]</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    X[T] <span class="ot">=</span> argmax_1 <span class="sc">&lt;=</span> k <span class="sc">&lt;=</span> <span class="fu">K</span> (TState[k, T]) </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="ot">=</span> T downto <span class="dv">2</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        X[i<span class="dv">-1</span>] <span class="ot">=</span> TIndex[X[i], i]</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    return X</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
</section>
<section id="оценка-эффективности-модели" class="level1">
<h1>Оценка эффективности модели</h1>
<section id="sensitivity-and-specificity" class="level2">
<h2 class="anchored" data-anchor-id="sensitivity-and-specificity">Sensitivity and specificity</h2>
<p><strong>Чувствительность (sensitivity)</strong> и <strong>специфичность (specificity)</strong> — статистические показатели диагностического теста по выявлению больных и здоровых, выводимых из ошибок первого и второго рода в бинарной классификации. Значения обоих показателей лежат в пределах от 0 до 1.</p>
<p><strong>Чувствительность</strong> (истинно положительная пропорция) отражает долю положительных результатов, которые правильно идентифицированы как таковые. Иными словами, чувствительность диагностического теста показывает вероятность того, что больной субъект будет классифицирован именно как больной.[1]</p>
<p><strong>Специфичность</strong> (истинно отрицательная пропорция) отражает долю отрицательных результатов, которые правильно идентифицированы как таковые, то есть вероятность того, что не больные субъекты будут классифицированы именно как не больные.[1]</p>
<p>Для примера можно рассмотреть группу, некоторые члены которой страдают определённым заболеванием, а остальные — нет. Предположим, что существует метод для разграничения этих двух долей, но при этом некоторые из здоровых классифицируются как больные, а некоторые из больных — как здоровые. Под «здоровым» и «больным» будем подразумевать отсутствие или наличие рассматриваемого заболевания. Это иллюстрируется на рисунке ниже «Общая модель чувствительности и специфичности».</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="_files/hmm/specificity.svg" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p><img src="_files/hmm/specificity1.svg" class="img-fluid"></p>
</section>
<section id="f-score" class="level2">
<h2 class="anchored" data-anchor-id="f-score">F-score</h2>
<p>F-score, или F-мера, – это метрика, широко применяемая для оценки качества классификационных моделей, особенно при работе с несбалансированными данными. Она объединяет точность (precision) и полноту (recall) в одно значение. Основная формула F-score выглядит так:</p>
<p><span class="math display">\[
F_β​=(1+\beta^2)⋅\frac{\text{precision}\cdot\text{recall}}{(\beta^2\cdot\text{precision})+\text{recall}}
\]</span></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="_files/hmm/fscore1.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<section id="определения" class="level3">
<h3 class="anchored" data-anchor-id="определения">Определения</h3>
<p><strong>Точность (Precision)</strong>: показывает, какая доля предсказанных моделью положительных результатов действительно является положительной. Она определяется как:</p>
<p><span class="math display">\[
\text{precision}=\frac{TP}{TP+FP}
\]</span></p>
<p>где <span class="math inline">\(TP\)</span> - количество истинных положительных случаев, а <span class="math inline">\(FP\)</span> - количество ложных положительных</p>
<p><strong>Полнота (Recall)</strong>: отражает, какая доля истинных положительных объектов была найдена моделью. Формула:</p>
<p><span class="math display">\[
\text{recall}=\frac{TP}{TP+FN}
\]</span></p>
<p>Здесь <span class="math inline">\(FN\)</span> - количество ложных отрицательных случаев</p>
</section>
<section id="параметр-beta" class="level3">
<h3 class="anchored" data-anchor-id="параметр-beta">Параметр <span class="math inline">\(\beta\)</span></h3>
<p>Параметр <span class="math inline">\(\beta\)</span> в формуле F-score используется для регулировки относительной важности точности и полноты. Чем больше&nbsp;$\beta$, тем выше значение полноты по отношению к точности. Соответственно, <span class="math inline">\(\beta &lt; 1\)</span> усиливает важность точности. Например:</p>
<ul>
<li><p><strong>F1-score</strong>&nbsp;(<span class="math inline">\(\beta\)</span>=1) – точность и полнота равны по весу.</p></li>
<li><p><strong>F2-score</strong>&nbsp;(<span class="math inline">\(\beta\)</span>=2) – полнота важнее в два раза, чем точность.</p></li>
</ul>
</section>
<section id="применение-f-score" class="level3">
<h3 class="anchored" data-anchor-id="применение-f-score">Применение F-score</h3>
<p>F-score широко применяется для оценки классификационных моделей, особенно в случаях, когда данные несбалансированы. В таких ситуациях стандартная точность модели может вводить в заблуждение, так как высокая точность может быть результатом редкого появления положительных классов. Например, в задаче обнаружения мошенничества большинство транзакций обычно честные, и классификатор, прогнозирующий все транзакции как честные, получит высокую точность, хотя он не обнаружит ни одного случая мошенничества. Здесь F-score становится важным инструментом, потому что он учитывает как точность (precision), так и полноту (recall), обеспечивая более сбалансированную оценку.</p>
<p>F-score особенно полезен в задачах информационного поиска, текстовой классификации, медицинской диагностики и других областях, где важно одновременно находить как можно больше значимых объектов (полнота) и минимизировать количество ложных срабатываний (точность). Например, в медицинских тестах при классификации болезни важно не только найти как можно больше положительных случаев (высокая полнота), но и избежать большого количества ложных диагнозов (высокая точность), которые могут вызвать ненужное беспокойство.</p>
<p>Таким образом, F-score является ключевой метрикой в задачах, где важно балансировать между полнотой и точностью, и может быть адаптирован для конкретных потребностей, выбирая подходящее значение параметра <span class="math inline">\(\beta\)</span>.</p>
</section>
</section>
</section>
<section id="домашнее-задание" class="level1">
<h1>Домашнее задание</h1>
<section id="цель" class="level2">
<h2 class="anchored" data-anchor-id="цель">Цель</h2>
<p>Научиться применять скрытую марковскую модель (HMM) для обнаружения CpG-островков в последовательности ДНК, закрепив теоретические знания, полученные на занятиях.</p>
</section>
<section id="задачи" class="level2">
<h2 class="anchored" data-anchor-id="задачи">Задачи</h2>
<ol type="1">
<li><p><strong>Определение модели</strong>: Задайте HMM с двумя состояниями («CpG» и «не-CpG»), указав разумные начальные значения для вероятностей переходов и эмиссий.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Для этого шага Вы можете использовать те же параметры, что и во время практического занятия.</p>
</div>
</div></li>
<li><p><strong>Реализация алгоритма</strong>: Реализуйте алгоритм Витерби на Python для поиска CpG-островков в длинной последовательности ДНК. Этот этап опирается на материал, изученный на занятии, где вы узнали, как применять алгоритм Витерби для нахождения наиболее вероятной последовательности состояний. Теперь ваша задача — применить эти знания к большему и более сложному набору данных.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>В качестве генома для анализа мы будем использовать геном рыбки Данио-рерио (<em>Danio Rerio</em>, Zebrafish). Данио-рерио является одним из наиболее изученных позвоночных наряду с крысами и мышами. Одним из преимуществ использования этой рыбы в качестве модельного организма является относительно небольшая длина генома ~1.5Gb.</p>
<p>Референсную последовательность генома Данио-рерио нужно скачать с сайта UCSC:<br>
<a href="http://hgdownload.soe.ucsc.edu/goldenPath/danRer11/bigZips/danRer11.fa.gz" class="uri">http://hgdownload.soe.ucsc.edu/goldenPath/danRer11/bigZips/danRer11.fa.gz</a></p>
<p>Аннотацию CpG островков следует скачаь с помощью UCSC Table Browser (в BED формате):</p>
<p><a href="https://genome.ucsc.edu/cgi-bin/hgTables" class="uri">https://genome.ucsc.edu/cgi-bin/hgTables</a></p>
</div>
</div></li>
<li><p><strong>Обучение алгоритмом Баум-Велша</strong>: Реализуйте алгоритм Баум-Велша для уточнения параметров модели. Этот алгоритм выбран для закрепления навыков, так как он дополняет алгоритм Витерби. В то время как Витерби используется для нахождения наиболее вероятного пути состояний, Баум-Велш позволяет подбирать оптимальные параметры HMM, опираясь исключительно на наблюдаемые данные, когда точные пути состояний неизвестны.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>Внимательно изучите принцип работы алгоритма: <a href="https://en.wikipedia.org/wiki/Baum–Welch_algorithm" class="uri">https://en.wikipedia.org/wiki/Baum–Welch_algorithm</a></p>
<p>Также, в качестве подсказки, приводим алгоритм на псевдокоде:</p>
<div class="cell">
<pre class="pseudocode cell-code"><code>BaumWelch(observations, states, transitions, emissions, max_iterations):
    Initialize transition and emission probabilities
    for iteration in range(max_iterations):
        # Expectation Step (E-Step)
        for each observation sequence:
            Compute forward probabilities (alpha)
            Compute backward probabilities (beta)

        # Maximization Step (M-Step)
        for each state i:
            for each state j:
                Update transition probability from state i to j

            for each observation symbol k:
                Update emission probability for state i to symbol k

    return updated transition and emission probabilities</code></pre>
</div>
<p>А также метод подсчета alpha:</p>
<div class="cell">
<pre class="pseudocode cell-code"><code>ComputeAlpha(observations, states, start_prob, transition_prob, emission_prob):
    Initialize alpha for the first observation:
    for each state i:
        alpha[0][i] = start_prob[i] * emission_prob[i][observations[0]]

    # Recursively compute alpha for the rest of the observations
    for t from 1 to length(observations) - 1:
        for each state i:
            alpha[t][i] = 0
            for each state j:
                alpha[t][i] += alpha[t - 1][j] * transition_prob[j][i]
            alpha[t][i] *= emission_prob[i][observations[t]]

    return alpha</code></pre>
</div>
<p>Метод подсчета beta Вам требуется придумать самим.</p>
</div>
</div></li>
<li><p><strong>Сравнение с реальными данными</strong>: Возьмите последовательность ДНК из публичной базы данных (например, NCBI) с известными CpG-островками и проверьте, насколько модель совпадает с существующими аннотациями. Сравнение результатов с реальными данными поможет оценить практическую полезность и точность модели.</p></li>
<li><p><strong>Оценка точности</strong>: Рассчитайте чувствительность, специфичность и F1-метрику для оценки работы модели, обсудив возможные причины расхождений. Эти метрики помогут количественно оценить точность модели и выявить направления для улучшения.</p></li>
</ol>
<p>Материалы для сдачи:</p>
<ol type="1">
<li><p><strong>Python-код</strong>: Отправьте документированные скрипты на Python.</p></li>
<li><p><strong>Отчет</strong> (3–5 страниц): Подготовьте подробный отчет, включающий описание подхода, трудностей, анализа чувствительности и результатов.</p></li>
</ol>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/shitohana\.github\.io\/POLYTECH_BIOINF_y4\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>