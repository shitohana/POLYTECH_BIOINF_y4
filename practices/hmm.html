<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.56">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>hmm – POLYTECH_BIOINF_y4</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="../site_libs/quarto-diagram/mermaid.min.js"></script>
<script src="../site_libs/quarto-diagram/mermaid-init.js"></script>
<link href="../site_libs/quarto-diagram/mermaid.css" rel="stylesheet">


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">POLYTECH_BIOINF_y4</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#введение" id="toc-введение" class="nav-link active" data-scroll-target="#введение">Введение</a></li>
  <li><a href="#практическое-задание" id="toc-практическое-задание" class="nav-link" data-scroll-target="#практическое-задание">Практическое задание</a>
  <ul class="collapse">
  <li><a href="#как-подготовить-hmm" id="toc-как-подготовить-hmm" class="nav-link" data-scroll-target="#как-подготовить-hmm">Как подготовить HMM?</a></li>
  <li><a href="#предисловие" id="toc-предисловие" class="nav-link" data-scroll-target="#предисловие">Предисловие</a>
  <ul class="collapse">
  <li><a href="#что-такое-cpg-островки" id="toc-что-такое-cpg-островки" class="nav-link" data-scroll-target="#что-такое-cpg-островки">Что такое CpG-островки?</a></li>
  </ul></li>
  <li><a href="#алгоритм-витерби-reminder" id="toc-алгоритм-витерби-reminder" class="nav-link" data-scroll-target="#алгоритм-витерби-reminder">Алгоритм Витерби (reminder)</a>
  <ul class="collapse">
  <li><a href="#как-подготовить-hmm.-частный-случай." id="toc-как-подготовить-hmm.-частный-случай." class="nav-link" data-scroll-target="#как-подготовить-hmm.-частный-случай.">Как подготовить HMM. Частный случай.</a></li>
  </ul></li>
  <li><a href="#имплементация-алгоритма" id="toc-имплементация-алгоритма" class="nav-link" data-scroll-target="#имплементация-алгоритма">Имплементация алгоритма</a></li>
  </ul></li>
  <li><a href="#домашнее-задание" id="toc-домашнее-задание" class="nav-link" data-scroll-target="#домашнее-задание">Домашнее задание</a>
  <ul class="collapse">
  <li><a href="#цель" id="toc-цель" class="nav-link" data-scroll-target="#цель">Цель</a></li>
  <li><a href="#задачи" id="toc-задачи" class="nav-link" data-scroll-target="#задачи">Задачи</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">




<p>Скрытые Марковские модели</p>
<section id="введение" class="level1">
<h1>Введение</h1>
<p>HMM (Hidden Markov Models, Скрытые Марковские модели) – это мощные статистические методы, позволяющие моделировать биологические последовательности и выявлять скрытые стохастические процессы, которые управляют их формированием.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="_files/hmm/hmm_scheme.jpeg" class="img-fluid quarto-figure quarto-figure-center figure-img" alt="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fm.youtube.com%2Fwatch%3Fv%3DRWkHJnFj5rY&amp;psig=AOvVaw18rQYPNv-xvGZq_2Gi1Trd&amp;ust=1731420593170000&amp;source=images&amp;cd=vfe&amp;opi=89978449&amp;ved=0CBcQjhxqFwoTCNDK3ry61IkDFQAAAAAdAAAAABAT"></p>
</figure>
</div>
<p>В биоинформатике HMM используются для анализа последовательностей, предсказания генов и обнаружения мотивов. Они особенно полезны в задачах, связанных с последовательными данными, где скрытые состояния (такие как, например, кодирующие и некодирующие регионы) оказывают влияние на наблюдаемые события (например, нуклеотидные последовательности).</p>
<p>HMM широко применяются для предсказания генов, помогая определить кодирующие участки ДНК и, таким образом, позволяют продолжить изучение структуры и функции генов. Они также используются в множественном выравнивании последовательностей, что помогает сопоставлять родственные последовательности и изучать эволюционные взаимосвязи.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="_files/hmm/hmm_scheme_seq.jpeg" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
</section>
<section id="практическое-задание" class="level1">
<h1>Практическое задание</h1>
<p>Данное практическое занятие будет посвящено применению HMM для поиска CpG-островков в геноме.</p>
<section id="как-подготовить-hmm" class="level3">
<h3 class="anchored" data-anchor-id="как-подготовить-hmm">Как подготовить HMM?</h3>
<p>Марковская модель описывает систему, которая переходит из одного состояния в другое, причем каждый переход зависит исключительно от текущего состояния (т.н. марковское свойство). Это означает, что будущее состояние системы определяется только ее текущим состоянием, а не всей предшествующей последовательностью событий.</p>
<p>Ключевые параметры для настройки модели:</p>
<ul>
<li><p>Состояния: Определите различные состояния, которые система может занимать.</p></li>
<li><p>Вероятности переходов: Укажите вероятности перехода из одного состояния в другое. Эти вероятности должны суммироваться до 1 для любого состояния, отражая все возможные пути, которые система может выбрать.</p></li>
<li><p>Начальные вероятности состояний: Задайте вероятности для того, чтобы система начала с определенного состояния. Эти вероятности используются для инициализации модели в начале последовательности.</p></li>
</ul>
</section>
<section id="предисловие" class="level2">
<h2 class="anchored" data-anchor-id="предисловие">Предисловие</h2>
<section id="что-такое-cpg-островки" class="level3">
<h3 class="anchored" data-anchor-id="что-такое-cpg-островки">Что такое CpG-островки?</h3>
<p>CpG-островки — это специфические участки ДНК с высокой частотой сочетаний цитозина и гуанина (обозначаемых как CpG), которые играют важную роль в регуляции генов. Эти островки часто располагаются рядом с промоторами — участками, ответственными за запуск транскрипции генов, — особенно в геномах эукариот.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="_files/hmm/cpg_island.jpeg" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p>Одной из ключевых особенностей CpG-островков в промоторных областях является то, что они обычно остаются неметилированными, что способствует активной экспрессии гена. Напротив, их метилирование может приводить к «выключению» гена, подавляя его активность. Поэтому состояние CpG-островков — метилированное или неметилированное — становится своего рода переключателем, который помогает регулировать, будет ли ген экспрессироваться или нет.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="_files/hmm/cpg_island2.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="background-color: white"></p>
</figure>
</div>
</section>
</section>
<section id="алгоритм-витерби-reminder" class="level2">
<h2 class="anchored" data-anchor-id="алгоритм-витерби-reminder">Алгоритм Витерби (reminder)</h2>
<p>Алгоритм Витерби — это метод динамического программирования, который позволяет определить наиболее вероятную последовательность скрытых состояний в скрытой марковской модели (HMM) для данной последовательности наблюдаемых событий. Алгоритм вычисляет путь, который максимизирует вероятность наблюдаемой последовательности, путем итеративного расчета наивысшей вероятности для каждого состояния на каждом этапе. При этом сохраняется информация как о вероятностях, так и о «указателях» (backpointer), необходимых для восстановления оптимального пути по завершении расчетов. Благодаря рекурсивному подходу алгоритм эффективно отслеживает путь, ведущий к каждому состоянию, избегая необходимости полного перебора всех возможных путей.</p>
<p>Почему выбран алгоритм Витерби для данной задачи? Алгоритм Витерби особенно подходит для выявления CpG-островков в последовательностях ДНК, так как он позволяет точно расшифровать последовательность в разные состояния (например, «CpG-островок» и «не-CpG-островок») на основе HMM. Высокая вычислительная эффективность делает его идеальным инструментом для анализа длинных последовательностей ДНК, типичных для биоинформатических исследований. Определяя наиболее вероятную последовательность скрытых состояний, алгоритм помогает выявлять биологически значимые области с высоким содержанием CG, что связано с функциями регуляции генов.</p>
<p>Aлгоритм Витерби находит широкое применение в различных областях биоинформатики и вычислительной биологии. Например, он используется для предсказания генов, помогая определить расположение экзонов и интронов в геномной последовательности. Алгоритм также применяется в множественном выравнивании последовательностей, где он помогает выровнять родственные биологические последовательности и выявить консервативные регионы. За пределами биоинформатики алгоритм Витерби также используется в системах распознавания речи, языковом моделировании и робототехнике для определения наиболее вероятной последовательности состояний в различных марковских системах.</p>
<section id="как-подготовить-hmm.-частный-случай." class="level3">
<h3 class="anchored" data-anchor-id="как-подготовить-hmm.-частный-случай.">Как подготовить HMM. Частный случай.</h3>
<p>Состояния: В этой HMM предусмотрены два состояния — «CpG-островок» и «не-CpG-островок». Состояние CpG-островка представляет области генома с высокой частотой цитозин-гуаниновых динуклеотидов (CG), тогда как состояние не-CpG-островка охватывает стандартные участки генома с низким содержанием CG.</p>
<p>Вероятности перехода: Вероятности перехода между состояниями определяют, какова вероятность перемещения из одного состояния в другое. Например, вероятность остаться в состоянии CpG-островка может быть высокой, что отражает их цельный, локализованный характер. В то же время вероятность перехода из состояния «не-CpG-островок» в «CpG-островок» может быть ниже, так как CpG-островки обычно сконцентрированы в определенных участках генома, часто около промоторных регионов генов.</p>
<p>Вероятности эмиссии: Вероятности эмиссии описывают вероятность наблюдения конкретных нуклеотидов (A, C, G, T) в каждом состоянии. Для CpG-островков характерна более высокая вероятность появления нуклеотидов C и G, что отражает их уникальный состав, тогда как в не-CpG-областях эти вероятности распределены более равномерно.</p>
<p>Моделирование CpG-островков: Параметры HMM — состояния, вероятности переходов и вероятности эмиссии — создают модель, способную распознать CpG-островки на основе их биологических особенностей, таких как высокое содержание CG и их расположение вблизи промоторных областей. Таким образом, модель не только различает CpG и не-CpG участки, но и выделяет те, что с наибольшей вероятностью играют роль в регуляции генов.</p>
<p>Графическое представление: Визуальная схема HMM наглядно отображает модель. В ней состояния представлены узлами, а переходы между ними — стрелками с указанием вероятностей. Такой граф помогает представить, как система переходит между состояниями и в какой последовательности.</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">stateDiagram-v2
    [*] --&gt; NonCpG

    state "Non-CpG" as NonCpG
    state "CpG Island" as CpG

    NonCpG --&gt; NonCpG : p = 0.999
    NonCpG --&gt; CpG : p = 0.001
    CpG --&gt; CpG : p = 0.995
    CpG --&gt; NonCpG : p = 0.005

    note right of NonCpG
        **Emission Probabilities:**
        A: 0.30
        C: 0.20
        G: 0.20
        T: 0.30
    end note

    note left of CpG
        **Emission Probabilities:**
        A: 0.15
        C: 0.35
        G: 0.35
        T: 0.15
    end note

</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
</section>
</section>
<section id="имплементация-алгоритма" class="level2">
<h2 class="anchored" data-anchor-id="имплементация-алгоритма">Имплементация алгоритма</h2>
<p>Инициализация матрицы Витерби При работе с алгоритмом Витерби первым шагом является инициализация матрицы, в которой будут храниться вероятности наиболее вероятных путей для каждого состояния на каждом шаге последовательности. Эта матрица позволяет моделировать вероятностный путь через последовательность ДНК, учитывая наиболее вероятные переходы между состояниями.</p>
<p>Итерация по последовательности В процессе итерации по последовательности ДНК, шаг за шагом, вычисляется вероятность нахождения в каждом из возможных состояний (например, «CpG-островок» или «не-CpG-островок») на каждом этапе последовательности. Этот шаг позволяет постепенно накапливать вероятности, связанные с каждым состоянием в последовательности.</p>
<p>Построение и использование матрицы Витерби Создание матрицы Витерби (V): Эта матрица (V) используется для хранения максимальной вероятности достижения каждого состояния в каждый момент последовательности. Дополнительно создается матрица указателей (backpointer), которая сохраняет наиболее вероятное предыдущее состояние для каждого текущего состояния, что будет полезно на этапе определения пути.</p>
<p>Выбор конечного состояния: В последней колонке матрицы V определяется состояние с наивысшей вероятностью, которое считается конечной точкой на наиболее вероятном пути.</p>
<p>Обратный проход (backtracking): Начиная с выбранного конечного состояния, матрица указателей используется для «обратного прохода» через последовательность, чтобы восстановить наиболее вероятный путь скрытых состояний. Этот процесс позволяет точно определить участки, такие как CpG-островки, в анализируемой последовательности.</p>
<p>Пример имплементации алгоритма (псевдокод)</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># --------------------- Initial model setup ---------------</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Define states and observations</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>states <span class="ot">=</span> [<span class="st">'CpG'</span>, <span class="st">'Non-CpG'</span>]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>observations <span class="ot">=</span> [<span class="st">'A'</span>, <span class="st">'T'</span>, <span class="st">'G'</span>, <span class="st">'C'</span>]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>map_state_to_index <span class="ot">=</span> {CpG<span class="sc">:</span> <span class="dv">0</span>, Non<span class="sc">-</span>CpG<span class="sc">:</span> <span class="dv">1</span>}</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>map_obs_to_index <span class="ot">=</span> {A<span class="sc">:</span> <span class="dv">0</span>, T<span class="sc">:</span> <span class="dv">1</span>, G<span class="sc">:</span> <span class="dv">2</span>, C<span class="sc">:</span> <span class="dv">3</span>}</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Define transition probability matrix between states</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>transition_probabilities <span class="ot">=</span> [</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Complete this part yourself for each state</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Define emission probability matrix from states to </span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="co"># observations</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>emission_probabilities <span class="ot">=</span> [</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Complete this part yourself for each state</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="co"># --------------------- Reading setup ---------------------</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Observed sequence (e.g., 'Obs1', 'Obs2', ...)</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>observed_sequence <span class="ot">=</span> read sequence</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert observed sequence to indices</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>observed_index_sequence <span class="ot">=</span> [map_obs_to_index[obs] <span class="cf">for</span> obs <span class="cf">in</span> observed_sequence]</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize parameters for Viterbi algorithm</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>number_of_states <span class="ot">=</span> length of states</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>sequence_length <span class="ot">=</span> length of observed_sequence</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a><span class="co"># Viterbi matrix to store highest probabilities</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>Viterbi_matrix <span class="ot">=</span> matrix of zeros with <span class="fu">dimensions</span> (number_of_states, sequence_length)</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a><span class="co"># Backpointer matrix to store best paths</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>backpointer_matrix <span class="ot">=</span> matrix of <span class="fu">zeros</span> (integer type) with <span class="fu">dimensions</span> (number_of_states, sequence_length)</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a><span class="co"># --------------------- Applying model --------------------</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialization step: Populate the first column of Viterbi </span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a><span class="co"># and backpointer matrices</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> each state s<span class="sc">:</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>    Viterbi_matrix[s, <span class="dv">0</span>] <span class="ot">=</span> emission_probabilities[s][observed_index_sequence[<span class="dv">0</span>]]</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>    backpointer_matrix[s, <span class="dv">0</span>] <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a><span class="co"># Iteration over each position in observed sequence</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> each position t from <span class="dv">1</span> to sequence_length <span class="sc">-</span> <span class="dv">1</span><span class="sc">:</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> each state s<span class="sc">:</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Calculate maximum probability of reaching state </span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>        <span class="co"># s from previous states</span></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>        transition_probs <span class="ot">=</span> [Viterbi_matrix[prev_state, t <span class="sc">-</span> <span class="dv">1</span>] <span class="sc">*</span> transition_probabilities[prev_state][s]</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>                            <span class="cf">for</span> each previous state]</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>        max_transition_prob <span class="ot">=</span> maximum value of transition_probs</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>        Viterbi_matrix[s, t] <span class="ot">=</span> max_transition_prob <span class="sc">*</span> emission_probabilities[s][observed_index_sequence[t]]</span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>        backpointer_matrix[s, t] <span class="ot">=</span> index of max_transition_prob</span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a><span class="co"># Termination step: Identify best last state</span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>last_state <span class="ot">=</span> index of maximum value <span class="cf">in</span> last column of Viterbi_matrix</span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>best_path <span class="ot">=</span> [last_state]</span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a><span class="co"># Backtrack to construct the optimal state path</span></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> each position t from sequence_length <span class="sc">-</span> <span class="dv">1</span> down to <span class="dv">1</span><span class="sc">:</span></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>    last_state <span class="ot">=</span> backpointer_matrix[last_state][t]</span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>    append last_state to best_path</span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a><span class="co"># Reverse best_path to get the correct order</span></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>best_path <span class="ot">=</span> reverse of best_path</span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a><span class="co"># --------------------- Finishing -------------------------</span></span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a><span class="co"># Map indices in best_path back to state names</span></span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>most_probable_states <span class="ot">=</span> [</span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>    states[state_index] <span class="cf">for</span> each state_index <span class="cf">in</span> best_path</span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a><span class="co"># Output the result</span></span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="st">"Most probable sequence of states:"</span>)</span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(most_probable_states)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="домашнее-задание" class="level1">
<h1>Домашнее задание</h1>
<section id="цель" class="level2">
<h2 class="anchored" data-anchor-id="цель">Цель</h2>
<p>Научиться применять скрытую марковскую модель (HMM) для обнаружения CpG-островков в последовательности ДНК, закрепив теоретические знания, полученные на занятиях.</p>
</section>
<section id="задачи" class="level2">
<h2 class="anchored" data-anchor-id="задачи">Задачи</h2>
<ol type="1">
<li><p><strong>Определение модели</strong>: Задайте HMM с двумя состояниями («CpG» и «не-CpG»), указав разумные начальные значения для вероятностей переходов и эмиссий.</p></li>
<li><p><strong>Реализация алгоритма</strong>: Реализуйте алгоритм Витерби на Python для поиска CpG-островков в длинной последовательности ДНК. Этот этап опирается на материал, изученный на занятии, где вы узнали, как применять алгоритм Витерби для нахождения наиболее вероятной последовательности состояний. Теперь ваша задача — применить эти знания к большему и более сложному набору данных.</p></li>
<li><p><strong>Обучение алгоритмом Баум-Велша</strong>: Реализуйте алгоритм Баум-Велша для уточнения параметров модели. Этот алгоритм выбран для закрепления навыков, так как он дополняет алгоритм Витерби. В то время как Витерби используется для нахождения наиболее вероятного пути состояний, Баум-Велш позволяет обучать параметры HMM, опираясь исключительно на наблюдаемые данные, когда точные пути состояний неизвестны. Таким образом, студенты получат целостное представление о HMM, переходя от декодирования к оценке параметров. Итогом работы станет способность корректировать вероятности переходов и эмиссий на основе реальных данных, улучшая точность модели.</p></li>
<li><p><strong>Визуализация</strong>: Постройте графическое изображение предсказанных CpG-островков (например, с использованием matplotlib). Визуализация позволяет интерпретировать работу модели, наглядно показывая, какие участки последовательности распознаются как CpG-островки.</p></li>
<li><p><strong>Анализ чувствительности параметров</strong>: Экспериментируйте с различными начальными значениями для вероятностей переходов и эмиссий и анализируйте, как это влияет на точность предсказаний и сходимость модели. Этот анализ поможет понять, насколько модель чувствительна к начальному выбору параметров, закрепив знания о её устойчивости и стабильности.</p></li>
<li><p><strong>Сравнение с реальными данными</strong>: Возьмите последовательность ДНК из публичной базы данных (например, NCBI) с известными CpG-островками и проверьте, насколько модель совпадает с существующими аннотациями. Сравнение результатов с реальными данными поможет оценить практическую полезность и точность модели.</p></li>
<li><p><strong>Оценка точности</strong>: Рассчитайте чувствительность, специфичность и F1-метрику для оценки работы модели, обсудив возможные причины расхождений. Эти метрики помогут количественно оценить точность модели и выявить направления для улучшения.</p></li>
</ol>
<p>Материалы для сдачи:</p>
<ol type="1">
<li><p><strong>Python-код</strong>: Отправьте документированные скрипты на Python.</p></li>
<li><p><strong>Отчет</strong> (3–5 страниц): Подготовьте подробный отчет, включающий описание подхода, трудностей, анализа чувствительности и результатов, а также графики и диаграммы.</p></li>
</ol>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/shitohana\.github\.io\/POLYTECH_BIOINF_y4\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>